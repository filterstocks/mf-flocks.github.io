webpackHotUpdate_N_E("pages/index",{

/***/ "./node_modules/.prisma/client/index-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/.prisma/client/index-browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst {\n  Decimal\n} = __webpack_require__(/*! @prisma/client/runtime/index-browser */ \"./node_modules/@prisma/client/runtime/index-browser.js\")\n\n\nconst Prisma = {}\n\nexports.Prisma = Prisma\n\n/**\n * Prisma Client JS version: 2.13.1\n * Query Engine version: fcbc4bb2d306c86c28014f596b1e8c7980af8bd4\n */\nPrisma.prismaVersion = {\n  client: \"2.13.1\",\n  engine: \"fcbc4bb2d306c86c28014f596b1e8c7980af8bd4\"\n}\n\nPrisma.PrismaClientKnownRequestError = () => {\n  throw new Error(`PrismaClientKnownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)};\nPrisma.PrismaClientUnknownRequestError = () => {\n  throw new Error(`PrismaClientUnknownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientRustPanicError = () => {\n  throw new Error(`PrismaClientRustPanicError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientInitializationError = () => {\n  throw new Error(`PrismaClientInitializationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientValidationError = () => {\n  throw new Error(`PrismaClientValidationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.Decimal = Decimal\n\n/**\n * Re-export of sql-template-tag\n */\n\nPrisma.sql = () => {\n  throw new Error(`sqltag is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.empty = () => {\n  throw new Error(`empty is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.join = () => {\n  throw new Error(`join is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.raw = () => {\n  throw new Error(`raw is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\n\n/**\n * Enums\n */\n// Based on\n// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nfunction makeEnum(x) { return x; }\n\nexports.Prisma.MetadataScalarFieldEnum = makeEnum({\n  id: 'id',\n  stock_name: 'stock_name',\n  isin: 'isin',\n  symbol: 'symbol',\n  paid_up_value: 'paid_up_value',\n  face_value: 'face_value',\n  created_at: 'created_at'\n});\n\nexports.Prisma.Mf_aumScalarFieldEnum = makeEnum({\n  id: 'id',\n  fund_house: 'fund_house',\n  month: 'month',\n  year: 'year',\n  aum: 'aum',\n  created_at: 'created_at'\n});\n\nexports.Prisma.Mutual_fundsScalarFieldEnum = makeEnum({\n  id: 'id',\n  fund_house: 'fund_house',\n  month: 'month',\n  year: 'year',\n  stock_name: 'stock_name',\n  isin: 'isin',\n  industry: 'industry',\n  quantity: 'quantity',\n  market_value: 'market_value',\n  percentage: 'percentage',\n  created_at: 'created_at',\n  updated_at: 'updated_at'\n});\n\nexports.Prisma.Mf_diffScalarFieldEnum = makeEnum({\n  id: 'id',\n  fund_house: 'fund_house',\n  fund_name: 'fund_name',\n  stock_name: 'stock_name',\n  isin: 'isin',\n  industry: 'industry',\n  current_month: 'current_month',\n  current_year: 'current_year',\n  previous_month: 'previous_month',\n  previous_year: 'previous_year',\n  state: 'state',\n  current_quantity: 'current_quantity',\n  previous_quantity: 'previous_quantity',\n  change_quantity: 'change_quantity',\n  change_market_value: 'change_market_value',\n  change_percentage_aum: 'change_percentage_aum',\n  created_at: 'created_at',\n  updated_at: 'updated_at'\n});\n\nexports.Prisma.SortOrder = makeEnum({\n  asc: 'asc',\n  desc: 'desc'\n});\n\n\nexports.Prisma.ModelName = makeEnum({\n  metadata: 'metadata',\n  mf_aum: 'mf_aum',\n  mutual_funds: 'mutual_funds',\n  mf_diff: 'mf_diff'\n});\n\n/**\n * Create the Client\n */\nclass PrismaClient {\n  constructor() {\n    throw new Error(\n      `PrismaClient is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma-client-js/issues`,\n    )\n  }\n}\nexports.PrismaClient = PrismaClient\n\nObject.assign(exports, Prisma)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wcmlzbWEvY2xpZW50L2luZGV4LWJyb3dzZXIuanM/NzZmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsOENBQThDLGNBQWM7O0FBRTVEO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQyxvR0FBc0M7OztBQUdsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCB7XG4gIERlY2ltYWxcbn0gPSByZXF1aXJlKCdAcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4LWJyb3dzZXInKVxuXG5cbmNvbnN0IFByaXNtYSA9IHt9XG5cbmV4cG9ydHMuUHJpc21hID0gUHJpc21hXG5cbi8qKlxuICogUHJpc21hIENsaWVudCBKUyB2ZXJzaW9uOiAyLjEzLjFcbiAqIFF1ZXJ5IEVuZ2luZSB2ZXJzaW9uOiBmY2JjNGJiMmQzMDZjODZjMjgwMTRmNTk2YjFlOGM3OTgwYWY4YmQ0XG4gKi9cblByaXNtYS5wcmlzbWFWZXJzaW9uID0ge1xuICBjbGllbnQ6IFwiMi4xMy4xXCIsXG4gIGVuZ2luZTogXCJmY2JjNGJiMmQzMDZjODZjMjgwMTRmNTk2YjFlOGM3OTgwYWY4YmQ0XCJcbn1cblxuUHJpc21hLlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfTtcblByaXNtYS5QcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuRGVjaW1hbCA9IERlY2ltYWxcblxuLyoqXG4gKiBSZS1leHBvcnQgb2Ygc3FsLXRlbXBsYXRlLXRhZ1xuICovXG5cblByaXNtYS5zcWwgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgc3FsdGFnIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLmVtcHR5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLmpvaW4gPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgam9pbiBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuKX1cblByaXNtYS5yYXcgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgcmF3IGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuXG4vKipcbiAqIEVudW1zXG4gKi9cbi8vIEJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxOTIjaXNzdWVjb21tZW50LTI2MTcyMDI3NVxuZnVuY3Rpb24gbWFrZUVudW0oeCkgeyByZXR1cm4geDsgfVxuXG5leHBvcnRzLlByaXNtYS5NZXRhZGF0YVNjYWxhckZpZWxkRW51bSA9IG1ha2VFbnVtKHtcbiAgaWQ6ICdpZCcsXG4gIHN0b2NrX25hbWU6ICdzdG9ja19uYW1lJyxcbiAgaXNpbjogJ2lzaW4nLFxuICBzeW1ib2w6ICdzeW1ib2wnLFxuICBwYWlkX3VwX3ZhbHVlOiAncGFpZF91cF92YWx1ZScsXG4gIGZhY2VfdmFsdWU6ICdmYWNlX3ZhbHVlJyxcbiAgY3JlYXRlZF9hdDogJ2NyZWF0ZWRfYXQnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuTWZfYXVtU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgZnVuZF9ob3VzZTogJ2Z1bmRfaG91c2UnLFxuICBtb250aDogJ21vbnRoJyxcbiAgeWVhcjogJ3llYXInLFxuICBhdW06ICdhdW0nLFxuICBjcmVhdGVkX2F0OiAnY3JlYXRlZF9hdCdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5NdXR1YWxfZnVuZHNTY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBmdW5kX2hvdXNlOiAnZnVuZF9ob3VzZScsXG4gIG1vbnRoOiAnbW9udGgnLFxuICB5ZWFyOiAneWVhcicsXG4gIHN0b2NrX25hbWU6ICdzdG9ja19uYW1lJyxcbiAgaXNpbjogJ2lzaW4nLFxuICBpbmR1c3RyeTogJ2luZHVzdHJ5JyxcbiAgcXVhbnRpdHk6ICdxdWFudGl0eScsXG4gIG1hcmtldF92YWx1ZTogJ21hcmtldF92YWx1ZScsXG4gIHBlcmNlbnRhZ2U6ICdwZXJjZW50YWdlJyxcbiAgY3JlYXRlZF9hdDogJ2NyZWF0ZWRfYXQnLFxuICB1cGRhdGVkX2F0OiAndXBkYXRlZF9hdCdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5NZl9kaWZmU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgZnVuZF9ob3VzZTogJ2Z1bmRfaG91c2UnLFxuICBmdW5kX25hbWU6ICdmdW5kX25hbWUnLFxuICBzdG9ja19uYW1lOiAnc3RvY2tfbmFtZScsXG4gIGlzaW46ICdpc2luJyxcbiAgaW5kdXN0cnk6ICdpbmR1c3RyeScsXG4gIGN1cnJlbnRfbW9udGg6ICdjdXJyZW50X21vbnRoJyxcbiAgY3VycmVudF95ZWFyOiAnY3VycmVudF95ZWFyJyxcbiAgcHJldmlvdXNfbW9udGg6ICdwcmV2aW91c19tb250aCcsXG4gIHByZXZpb3VzX3llYXI6ICdwcmV2aW91c195ZWFyJyxcbiAgc3RhdGU6ICdzdGF0ZScsXG4gIGN1cnJlbnRfcXVhbnRpdHk6ICdjdXJyZW50X3F1YW50aXR5JyxcbiAgcHJldmlvdXNfcXVhbnRpdHk6ICdwcmV2aW91c19xdWFudGl0eScsXG4gIGNoYW5nZV9xdWFudGl0eTogJ2NoYW5nZV9xdWFudGl0eScsXG4gIGNoYW5nZV9tYXJrZXRfdmFsdWU6ICdjaGFuZ2VfbWFya2V0X3ZhbHVlJyxcbiAgY2hhbmdlX3BlcmNlbnRhZ2VfYXVtOiAnY2hhbmdlX3BlcmNlbnRhZ2VfYXVtJyxcbiAgY3JlYXRlZF9hdDogJ2NyZWF0ZWRfYXQnLFxuICB1cGRhdGVkX2F0OiAndXBkYXRlZF9hdCdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5Tb3J0T3JkZXIgPSBtYWtlRW51bSh7XG4gIGFzYzogJ2FzYycsXG4gIGRlc2M6ICdkZXNjJ1xufSk7XG5cblxuZXhwb3J0cy5QcmlzbWEuTW9kZWxOYW1lID0gbWFrZUVudW0oe1xuICBtZXRhZGF0YTogJ21ldGFkYXRhJyxcbiAgbWZfYXVtOiAnbWZfYXVtJyxcbiAgbXV0dWFsX2Z1bmRzOiAnbXV0dWFsX2Z1bmRzJyxcbiAgbWZfZGlmZjogJ21mX2RpZmYnXG59KTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIENsaWVudFxuICovXG5jbGFzcyBQcmlzbWFDbGllbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUHJpc21hQ2xpZW50IGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hLWNsaWVudC1qcy9pc3N1ZXNgLFxuICAgIClcbiAgfVxufVxuZXhwb3J0cy5QcmlzbWFDbGllbnQgPSBQcmlzbWFDbGllbnRcblxuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBQcmlzbWEpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.prisma/client/index-browser.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/index-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/@prisma/client/index-browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const prisma = __webpack_require__(/*! .prisma/client/index-browser */ \"./node_modules/.prisma/client/index-browser.js\")\n\nmodule.exports = prisma\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50L2luZGV4LWJyb3dzZXIuanM/ZDVjYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsb0ZBQThCOztBQUVyRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9pbmRleC1icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJpc21hID0gcmVxdWlyZSgnLnByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3NlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gcHJpc21hXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/index-browser.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/runtime/index-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/index-browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (callback, module2) => () => {\n  if (!module2) {\n    module2 = {exports: {}};\n    callback(module2.exports, module2);\n  }\n  return module2.exports;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, {get: all[name], enumerable: true});\n};\nvar __exportStar = (target, module2, desc) => {\n  __markAsModule(target);\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  if (module2 && module2.__esModule)\n    return module2;\n  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", {value: module2, enumerable: true}), module2);\n};\n\n// ../../node_modules/.pnpm/decimal.js@10.2.1/node_modules/decimal.js/decimal.js\nvar require_decimal = __commonJS((exports2, module2) => {\n  (function(globalScope) {\n    \"use strict\";\n    var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = \"0123456789abcdef\", LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", DEFAULTS = {\n      precision: 20,\n      rounding: 4,\n      modulo: 1,\n      toExpNeg: -7,\n      toExpPos: 21,\n      minE: -EXP_LIMIT,\n      maxE: EXP_LIMIT,\n      crypto: false\n    }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = {name: \"[object Decimal]\"};\n    P.absoluteValue = P.abs = function() {\n      var x = new this.constructor(this);\n      if (x.s < 0)\n        x.s = 1;\n      return finalise(x);\n    };\n    P.ceil = function() {\n      return finalise(new this.constructor(this), this.e + 1, 2);\n    };\n    P.comparedTo = P.cmp = function(y) {\n      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n      if (!xd || !yd) {\n        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n      }\n      if (!xd[0] || !yd[0])\n        return xd[0] ? xs : yd[0] ? -ys : 0;\n      if (xs !== ys)\n        return xs;\n      if (x.e !== y.e)\n        return x.e > y.e ^ xs < 0 ? 1 : -1;\n      xdL = xd.length;\n      ydL = yd.length;\n      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n        if (xd[i] !== yd[i])\n          return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n      }\n      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n    };\n    P.cosine = P.cos = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (!x.d)\n        return new Ctor(NaN);\n      if (!x.d[0])\n        return new Ctor(1);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n      Ctor.rounding = 1;\n      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n    };\n    P.cubeRoot = P.cbrt = function() {\n      var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n      if (!x.isFinite() || x.isZero())\n        return new Ctor(x);\n      external = false;\n      s = x.s * mathpow(x.s * x, 1 / 3);\n      if (!s || Math.abs(s) == 1 / 0) {\n        n = digitsToString(x.d);\n        e = x.e;\n        if (s = (e - n.length + 1) % 3)\n          n += s == 1 || s == -2 ? \"0\" : \"00\";\n        s = mathpow(n, 1 / 3);\n        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n        if (s == 1 / 0) {\n          n = \"5e\" + e;\n        } else {\n          n = s.toExponential();\n          n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n        r.s = x.s;\n      } else {\n        r = new Ctor(s.toString());\n      }\n      sd = (e = Ctor.precision) + 3;\n      for (; ; ) {\n        t = r;\n        t3 = t.times(t).times(t);\n        t3plusx = t3.plus(x);\n        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n          n = n.slice(sd - 3, sd + 1);\n          if (n == \"9999\" || !rep && n == \"4999\") {\n            if (!rep) {\n              finalise(t, e + 1, 0);\n              if (t.times(t).times(t).eq(x)) {\n                r = t;\n                break;\n              }\n            }\n            sd += 4;\n            rep = 1;\n          } else {\n            if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n              finalise(r, e + 1, 1);\n              m = !r.times(r).times(r).eq(x);\n            }\n            break;\n          }\n        }\n      }\n      external = true;\n      return finalise(r, e, Ctor.rounding, m);\n    };\n    P.decimalPlaces = P.dp = function() {\n      var w, d = this.d, n = NaN;\n      if (d) {\n        w = d.length - 1;\n        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n        w = d[w];\n        if (w)\n          for (; w % 10 == 0; w /= 10)\n            n--;\n        if (n < 0)\n          n = 0;\n      }\n      return n;\n    };\n    P.dividedBy = P.div = function(y) {\n      return divide(this, new this.constructor(y));\n    };\n    P.dividedToIntegerBy = P.divToInt = function(y) {\n      var x = this, Ctor = x.constructor;\n      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n    };\n    P.equals = P.eq = function(y) {\n      return this.cmp(y) === 0;\n    };\n    P.floor = function() {\n      return finalise(new this.constructor(this), this.e + 1, 3);\n    };\n    P.greaterThan = P.gt = function(y) {\n      return this.cmp(y) > 0;\n    };\n    P.greaterThanOrEqualTo = P.gte = function(y) {\n      var k = this.cmp(y);\n      return k == 1 || k === 0;\n    };\n    P.hyperbolicCosine = P.cosh = function() {\n      var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n      if (!x.isFinite())\n        return new Ctor(x.s ? 1 / 0 : NaN);\n      if (x.isZero())\n        return one;\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n      Ctor.rounding = 1;\n      len = x.d.length;\n      if (len < 32) {\n        k = Math.ceil(len / 3);\n        n = (1 / tinyPow(4, k)).toString();\n      } else {\n        k = 16;\n        n = \"2.3283064365386962890625e-10\";\n      }\n      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n      var cosh2_x, i = k, d8 = new Ctor(8);\n      for (; i--; ) {\n        cosh2_x = x.times(x);\n        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n      }\n      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n    };\n    P.hyperbolicSine = P.sinh = function() {\n      var k, pr, rm, len, x = this, Ctor = x.constructor;\n      if (!x.isFinite() || x.isZero())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n      Ctor.rounding = 1;\n      len = x.d.length;\n      if (len < 3) {\n        x = taylorSeries(Ctor, 2, x, x, true);\n      } else {\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x, true);\n        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for (; k--; ) {\n          sinh2_x = x.times(x);\n          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n        }\n      }\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return finalise(x, pr, rm, true);\n    };\n    P.hyperbolicTangent = P.tanh = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (!x.isFinite())\n        return new Ctor(x.s);\n      if (x.isZero())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + 7;\n      Ctor.rounding = 1;\n      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n    };\n    P.inverseCosine = P.acos = function() {\n      var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n      if (k !== -1) {\n        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n      }\n      if (x.isZero())\n        return getPi(Ctor, pr + 4, rm).times(0.5);\n      Ctor.precision = pr + 6;\n      Ctor.rounding = 1;\n      x = x.asin();\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return halfPi.minus(x);\n    };\n    P.inverseHyperbolicCosine = P.acosh = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (x.lte(1))\n        return new Ctor(x.eq(1) ? 0 : NaN);\n      if (!x.isFinite())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n      Ctor.rounding = 1;\n      external = false;\n      x = x.times(x).minus(1).sqrt().plus(x);\n      external = true;\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return x.ln();\n    };\n    P.inverseHyperbolicSine = P.asinh = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (!x.isFinite() || x.isZero())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n      Ctor.rounding = 1;\n      external = false;\n      x = x.times(x).plus(1).sqrt().plus(x);\n      external = true;\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return x.ln();\n    };\n    P.inverseHyperbolicTangent = P.atanh = function() {\n      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n      if (!x.isFinite())\n        return new Ctor(NaN);\n      if (x.e >= 0)\n        return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      xsd = x.sd();\n      if (Math.max(xsd, pr) < 2 * -x.e - 1)\n        return finalise(new Ctor(x), pr, rm, true);\n      Ctor.precision = wpr = xsd - x.e;\n      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n      Ctor.precision = pr + 4;\n      Ctor.rounding = 1;\n      x = x.ln();\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return x.times(0.5);\n    };\n    P.inverseSine = P.asin = function() {\n      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n      if (x.isZero())\n        return new Ctor(x);\n      k = x.abs().cmp(1);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      if (k !== -1) {\n        if (k === 0) {\n          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n          halfPi.s = x.s;\n          return halfPi;\n        }\n        return new Ctor(NaN);\n      }\n      Ctor.precision = pr + 6;\n      Ctor.rounding = 1;\n      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return x.times(2);\n    };\n    P.inverseTangent = P.atan = function() {\n      var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n      if (!x.isFinite()) {\n        if (!x.s)\n          return new Ctor(NaN);\n        if (pr + 4 <= PI_PRECISION) {\n          r = getPi(Ctor, pr + 4, rm).times(0.5);\n          r.s = x.s;\n          return r;\n        }\n      } else if (x.isZero()) {\n        return new Ctor(x);\n      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.25);\n        r.s = x.s;\n        return r;\n      }\n      Ctor.precision = wpr = pr + 10;\n      Ctor.rounding = 1;\n      k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n      for (i = k; i; --i)\n        x = x.div(x.times(x).plus(1).sqrt().plus(1));\n      external = false;\n      j = Math.ceil(wpr / LOG_BASE);\n      n = 1;\n      x2 = x.times(x);\n      r = new Ctor(x);\n      px = x;\n      for (; i !== -1; ) {\n        px = px.times(x2);\n        t = r.minus(px.div(n += 2));\n        px = px.times(x2);\n        r = t.plus(px.div(n += 2));\n        if (r.d[j] !== void 0)\n          for (i = j; r.d[i] === t.d[i] && i--; )\n            ;\n      }\n      if (k)\n        r = r.times(2 << k - 1);\n      external = true;\n      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n    };\n    P.isFinite = function() {\n      return !!this.d;\n    };\n    P.isInteger = P.isInt = function() {\n      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n    };\n    P.isNaN = function() {\n      return !this.s;\n    };\n    P.isNegative = P.isNeg = function() {\n      return this.s < 0;\n    };\n    P.isPositive = P.isPos = function() {\n      return this.s > 0;\n    };\n    P.isZero = function() {\n      return !!this.d && this.d[0] === 0;\n    };\n    P.lessThan = P.lt = function(y) {\n      return this.cmp(y) < 0;\n    };\n    P.lessThanOrEqualTo = P.lte = function(y) {\n      return this.cmp(y) < 1;\n    };\n    P.logarithm = P.log = function(base) {\n      var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n      if (base == null) {\n        base = new Ctor(10);\n        isBase10 = true;\n      } else {\n        base = new Ctor(base);\n        d = base.d;\n        if (base.s < 0 || !d || !d[0] || base.eq(1))\n          return new Ctor(NaN);\n        isBase10 = base.eq(10);\n      }\n      d = arg.d;\n      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n      }\n      if (isBase10) {\n        if (d.length > 1) {\n          inf = true;\n        } else {\n          for (k = d[0]; k % 10 === 0; )\n            k /= 10;\n          inf = k !== 1;\n        }\n      }\n      external = false;\n      sd = pr + guard;\n      num = naturalLogarithm(arg, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (checkRoundingDigits(r.d, k = pr, rm)) {\n        do {\n          sd += 10;\n          num = naturalLogarithm(arg, sd);\n          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n          r = divide(num, denominator, sd, 1);\n          if (!inf) {\n            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n              r = finalise(r, pr + 1, 0);\n            }\n            break;\n          }\n        } while (checkRoundingDigits(r.d, k += 10, rm));\n      }\n      external = true;\n      return finalise(r, pr, rm);\n    };\n    P.minus = P.sub = function(y) {\n      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n      y = new Ctor(y);\n      if (!x.d || !y.d) {\n        if (!x.s || !y.s)\n          y = new Ctor(NaN);\n        else if (x.d)\n          y.s = -y.s;\n        else\n          y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n        return y;\n      }\n      if (x.s != y.s) {\n        y.s = -y.s;\n        return x.plus(y);\n      }\n      xd = x.d;\n      yd = y.d;\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      if (!xd[0] || !yd[0]) {\n        if (yd[0])\n          y.s = -y.s;\n        else if (xd[0])\n          y = new Ctor(x);\n        else\n          return new Ctor(rm === 3 ? -0 : 0);\n        return external ? finalise(y, pr, rm) : y;\n      }\n      e = mathfloor(y.e / LOG_BASE);\n      xe = mathfloor(x.e / LOG_BASE);\n      xd = xd.slice();\n      k = xe - e;\n      if (k) {\n        xLTy = k < 0;\n        if (xLTy) {\n          d = xd;\n          k = -k;\n          len = yd.length;\n        } else {\n          d = yd;\n          e = xe;\n          len = xd.length;\n        }\n        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n        if (k > i) {\n          k = i;\n          d.length = 1;\n        }\n        d.reverse();\n        for (i = k; i--; )\n          d.push(0);\n        d.reverse();\n      } else {\n        i = xd.length;\n        len = yd.length;\n        xLTy = i < len;\n        if (xLTy)\n          len = i;\n        for (i = 0; i < len; i++) {\n          if (xd[i] != yd[i]) {\n            xLTy = xd[i] < yd[i];\n            break;\n          }\n        }\n        k = 0;\n      }\n      if (xLTy) {\n        d = xd;\n        xd = yd;\n        yd = d;\n        y.s = -y.s;\n      }\n      len = xd.length;\n      for (i = yd.length - len; i > 0; --i)\n        xd[len++] = 0;\n      for (i = yd.length; i > k; ) {\n        if (xd[--i] < yd[i]) {\n          for (j = i; j && xd[--j] === 0; )\n            xd[j] = BASE - 1;\n          --xd[j];\n          xd[i] += BASE;\n        }\n        xd[i] -= yd[i];\n      }\n      for (; xd[--len] === 0; )\n        xd.pop();\n      for (; xd[0] === 0; xd.shift())\n        --e;\n      if (!xd[0])\n        return new Ctor(rm === 3 ? -0 : 0);\n      y.d = xd;\n      y.e = getBase10Exponent(xd, e);\n      return external ? finalise(y, pr, rm) : y;\n    };\n    P.modulo = P.mod = function(y) {\n      var q, x = this, Ctor = x.constructor;\n      y = new Ctor(y);\n      if (!x.d || !y.s || y.d && !y.d[0])\n        return new Ctor(NaN);\n      if (!y.d || x.d && !x.d[0]) {\n        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n      }\n      external = false;\n      if (Ctor.modulo == 9) {\n        q = divide(x, y.abs(), 0, 3, 1);\n        q.s *= y.s;\n      } else {\n        q = divide(x, y, 0, Ctor.modulo, 1);\n      }\n      q = q.times(y);\n      external = true;\n      return x.minus(q);\n    };\n    P.naturalExponential = P.exp = function() {\n      return naturalExponential(this);\n    };\n    P.naturalLogarithm = P.ln = function() {\n      return naturalLogarithm(this);\n    };\n    P.negated = P.neg = function() {\n      var x = new this.constructor(this);\n      x.s = -x.s;\n      return finalise(x);\n    };\n    P.plus = P.add = function(y) {\n      var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n      y = new Ctor(y);\n      if (!x.d || !y.d) {\n        if (!x.s || !y.s)\n          y = new Ctor(NaN);\n        else if (!x.d)\n          y = new Ctor(y.d || x.s === y.s ? x : NaN);\n        return y;\n      }\n      if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n      }\n      xd = x.d;\n      yd = y.d;\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      if (!xd[0] || !yd[0]) {\n        if (!yd[0])\n          y = new Ctor(x);\n        return external ? finalise(y, pr, rm) : y;\n      }\n      k = mathfloor(x.e / LOG_BASE);\n      e = mathfloor(y.e / LOG_BASE);\n      xd = xd.slice();\n      i = k - e;\n      if (i) {\n        if (i < 0) {\n          d = xd;\n          i = -i;\n          len = yd.length;\n        } else {\n          d = yd;\n          e = k;\n          len = xd.length;\n        }\n        k = Math.ceil(pr / LOG_BASE);\n        len = k > len ? k + 1 : len + 1;\n        if (i > len) {\n          i = len;\n          d.length = 1;\n        }\n        d.reverse();\n        for (; i--; )\n          d.push(0);\n        d.reverse();\n      }\n      len = xd.length;\n      i = yd.length;\n      if (len - i < 0) {\n        i = len;\n        d = yd;\n        yd = xd;\n        xd = d;\n      }\n      for (carry = 0; i; ) {\n        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n        xd[i] %= BASE;\n      }\n      if (carry) {\n        xd.unshift(carry);\n        ++e;\n      }\n      for (len = xd.length; xd[--len] == 0; )\n        xd.pop();\n      y.d = xd;\n      y.e = getBase10Exponent(xd, e);\n      return external ? finalise(y, pr, rm) : y;\n    };\n    P.precision = P.sd = function(z) {\n      var k, x = this;\n      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)\n        throw Error(invalidArgument + z);\n      if (x.d) {\n        k = getPrecision(x.d);\n        if (z && x.e + 1 > k)\n          k = x.e + 1;\n      } else {\n        k = NaN;\n      }\n      return k;\n    };\n    P.round = function() {\n      var x = this, Ctor = x.constructor;\n      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n    };\n    P.sine = P.sin = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (!x.isFinite())\n        return new Ctor(NaN);\n      if (x.isZero())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n      Ctor.rounding = 1;\n      x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n    };\n    P.squareRoot = P.sqrt = function() {\n      var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n      if (s !== 1 || !d || !d[0]) {\n        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n      }\n      external = false;\n      s = Math.sqrt(+x);\n      if (s == 0 || s == 1 / 0) {\n        n = digitsToString(d);\n        if ((n.length + e) % 2 == 0)\n          n += \"0\";\n        s = Math.sqrt(n);\n        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n        if (s == 1 / 0) {\n          n = \"5e\" + e;\n        } else {\n          n = s.toExponential();\n          n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n      } else {\n        r = new Ctor(s.toString());\n      }\n      sd = (e = Ctor.precision) + 3;\n      for (; ; ) {\n        t = r;\n        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n          n = n.slice(sd - 3, sd + 1);\n          if (n == \"9999\" || !rep && n == \"4999\") {\n            if (!rep) {\n              finalise(t, e + 1, 0);\n              if (t.times(t).eq(x)) {\n                r = t;\n                break;\n              }\n            }\n            sd += 4;\n            rep = 1;\n          } else {\n            if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n              finalise(r, e + 1, 1);\n              m = !r.times(r).eq(x);\n            }\n            break;\n          }\n        }\n      }\n      external = true;\n      return finalise(r, e, Ctor.rounding, m);\n    };\n    P.tangent = P.tan = function() {\n      var pr, rm, x = this, Ctor = x.constructor;\n      if (!x.isFinite())\n        return new Ctor(NaN);\n      if (x.isZero())\n        return new Ctor(x);\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      Ctor.precision = pr + 10;\n      Ctor.rounding = 1;\n      x = x.sin();\n      x.s = 1;\n      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n      Ctor.precision = pr;\n      Ctor.rounding = rm;\n      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n    };\n    P.times = P.mul = function(y) {\n      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n      y.s *= x.s;\n      if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n      }\n      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n      xdL = xd.length;\n      ydL = yd.length;\n      if (xdL < ydL) {\n        r = xd;\n        xd = yd;\n        yd = r;\n        rL = xdL;\n        xdL = ydL;\n        ydL = rL;\n      }\n      r = [];\n      rL = xdL + ydL;\n      for (i = rL; i--; )\n        r.push(0);\n      for (i = ydL; --i >= 0; ) {\n        carry = 0;\n        for (k = xdL + i; k > i; ) {\n          t = r[k] + yd[i] * xd[k - i - 1] + carry;\n          r[k--] = t % BASE | 0;\n          carry = t / BASE | 0;\n        }\n        r[k] = (r[k] + carry) % BASE | 0;\n      }\n      for (; !r[--rL]; )\n        r.pop();\n      if (carry)\n        ++e;\n      else\n        r.shift();\n      y.d = r;\n      y.e = getBase10Exponent(r, e);\n      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n    };\n    P.toBinary = function(sd, rm) {\n      return toStringBinary(this, 2, sd, rm);\n    };\n    P.toDecimalPlaces = P.toDP = function(dp, rm) {\n      var x = this, Ctor = x.constructor;\n      x = new Ctor(x);\n      if (dp === void 0)\n        return x;\n      checkInt32(dp, 0, MAX_DIGITS);\n      if (rm === void 0)\n        rm = Ctor.rounding;\n      else\n        checkInt32(rm, 0, 8);\n      return finalise(x, dp + x.e + 1, rm);\n    };\n    P.toExponential = function(dp, rm) {\n      var str, x = this, Ctor = x.constructor;\n      if (dp === void 0) {\n        str = finiteToString(x, true);\n      } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0)\n          rm = Ctor.rounding;\n        else\n          checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), dp + 1, rm);\n        str = finiteToString(x, true, dp + 1);\n      }\n      return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    P.toFixed = function(dp, rm) {\n      var str, y, x = this, Ctor = x.constructor;\n      if (dp === void 0) {\n        str = finiteToString(x);\n      } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0)\n          rm = Ctor.rounding;\n        else\n          checkInt32(rm, 0, 8);\n        y = finalise(new Ctor(x), dp + x.e + 1, rm);\n        str = finiteToString(y, false, dp + y.e + 1);\n      }\n      return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    P.toFraction = function(maxD) {\n      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n      if (!xd)\n        return new Ctor(x);\n      n1 = d0 = new Ctor(1);\n      d1 = n0 = new Ctor(0);\n      d = new Ctor(d1);\n      e = d.e = getPrecision(xd) - x.e - 1;\n      k = e % LOG_BASE;\n      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n      if (maxD == null) {\n        maxD = e > 0 ? d : n1;\n      } else {\n        n = new Ctor(maxD);\n        if (!n.isInt() || n.lt(n1))\n          throw Error(invalidArgument + n);\n        maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n      }\n      external = false;\n      n = new Ctor(digitsToString(xd));\n      pr = Ctor.precision;\n      Ctor.precision = e = xd.length * LOG_BASE * 2;\n      for (; ; ) {\n        q = divide(n, d, 0, 1, 1);\n        d2 = d0.plus(q.times(d1));\n        if (d2.cmp(maxD) == 1)\n          break;\n        d0 = d1;\n        d1 = d2;\n        d2 = n1;\n        n1 = n0.plus(q.times(d2));\n        n0 = d2;\n        d2 = d;\n        d = n.minus(q.times(d2));\n        n = d2;\n      }\n      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n      n0 = n0.plus(d2.times(n1));\n      d0 = d0.plus(d2.times(d1));\n      n0.s = n1.s = x.s;\n      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n      Ctor.precision = pr;\n      external = true;\n      return r;\n    };\n    P.toHexadecimal = P.toHex = function(sd, rm) {\n      return toStringBinary(this, 16, sd, rm);\n    };\n    P.toNearest = function(y, rm) {\n      var x = this, Ctor = x.constructor;\n      x = new Ctor(x);\n      if (y == null) {\n        if (!x.d)\n          return x;\n        y = new Ctor(1);\n        rm = Ctor.rounding;\n      } else {\n        y = new Ctor(y);\n        if (rm === void 0) {\n          rm = Ctor.rounding;\n        } else {\n          checkInt32(rm, 0, 8);\n        }\n        if (!x.d)\n          return y.s ? x : y;\n        if (!y.d) {\n          if (y.s)\n            y.s = x.s;\n          return y;\n        }\n      }\n      if (y.d[0]) {\n        external = false;\n        x = divide(x, y, 0, rm, 1).times(y);\n        external = true;\n        finalise(x);\n      } else {\n        y.s = x.s;\n        x = y;\n      }\n      return x;\n    };\n    P.toNumber = function() {\n      return +this;\n    };\n    P.toOctal = function(sd, rm) {\n      return toStringBinary(this, 8, sd, rm);\n    };\n    P.toPower = P.pow = function(y) {\n      var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n      if (!x.d || !y.d || !x.d[0] || !y.d[0])\n        return new Ctor(mathpow(+x, yn));\n      x = new Ctor(x);\n      if (x.eq(1))\n        return x;\n      pr = Ctor.precision;\n      rm = Ctor.rounding;\n      if (y.eq(1))\n        return finalise(x, pr, rm);\n      e = mathfloor(y.e / LOG_BASE);\n      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n        r = intPow(Ctor, x, k, pr);\n        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n      }\n      s = x.s;\n      if (s < 0) {\n        if (e < y.d.length - 1)\n          return new Ctor(NaN);\n        if ((y.d[e] & 1) == 0)\n          s = 1;\n        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n          x.s = s;\n          return x;\n        }\n      }\n      k = mathpow(+x, yn);\n      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)\n        return new Ctor(e > 0 ? s / 0 : 0);\n      external = false;\n      Ctor.rounding = x.s = 1;\n      k = Math.min(12, (e + \"\").length);\n      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n      if (r.d) {\n        r = finalise(r, pr + 5, 1);\n        if (checkRoundingDigits(r.d, pr, rm)) {\n          e = pr + 10;\n          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n            r = finalise(r, pr + 1, 0);\n          }\n        }\n      }\n      r.s = s;\n      external = true;\n      Ctor.rounding = rm;\n      return finalise(r, pr, rm);\n    };\n    P.toPrecision = function(sd, rm) {\n      var str, x = this, Ctor = x.constructor;\n      if (sd === void 0) {\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n      } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0)\n          rm = Ctor.rounding;\n        else\n          checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), sd, rm);\n        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n      }\n      return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    P.toSignificantDigits = P.toSD = function(sd, rm) {\n      var x = this, Ctor = x.constructor;\n      if (sd === void 0) {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n      } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0)\n          rm = Ctor.rounding;\n        else\n          checkInt32(rm, 0, 8);\n      }\n      return finalise(new Ctor(x), sd, rm);\n    };\n    P.toString = function() {\n      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n      return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    P.truncated = P.trunc = function() {\n      return finalise(new this.constructor(this), this.e + 1, 1);\n    };\n    P.valueOf = P.toJSON = function() {\n      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n      return x.isNeg() ? \"-\" + str : str;\n    };\n    function digitsToString(d) {\n      var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n      if (indexOfLastWord > 0) {\n        str += w;\n        for (i = 1; i < indexOfLastWord; i++) {\n          ws = d[i] + \"\";\n          k = LOG_BASE - ws.length;\n          if (k)\n            str += getZeroString(k);\n          str += ws;\n        }\n        w = d[i];\n        ws = w + \"\";\n        k = LOG_BASE - ws.length;\n        if (k)\n          str += getZeroString(k);\n      } else if (w === 0) {\n        return \"0\";\n      }\n      for (; w % 10 === 0; )\n        w /= 10;\n      return str + w;\n    }\n    function checkInt32(i, min2, max2) {\n      if (i !== ~~i || i < min2 || i > max2) {\n        throw Error(invalidArgument + i);\n      }\n    }\n    function checkRoundingDigits(d, i, rm, repeating) {\n      var di, k, r, rd;\n      for (k = d[0]; k >= 10; k /= 10)\n        --i;\n      if (--i < 0) {\n        i += LOG_BASE;\n        di = 0;\n      } else {\n        di = Math.ceil((i + 1) / LOG_BASE);\n        i %= LOG_BASE;\n      }\n      k = mathpow(10, LOG_BASE - i);\n      rd = d[di] % k | 0;\n      if (repeating == null) {\n        if (i < 3) {\n          if (i == 0)\n            rd = rd / 100 | 0;\n          else if (i == 1)\n            rd = rd / 10 | 0;\n          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n        } else {\n          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n        }\n      } else {\n        if (i < 4) {\n          if (i == 0)\n            rd = rd / 1e3 | 0;\n          else if (i == 1)\n            rd = rd / 100 | 0;\n          else if (i == 2)\n            rd = rd / 10 | 0;\n          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n        } else {\n          r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n        }\n      }\n      return r;\n    }\n    function convertBase(str, baseIn, baseOut) {\n      var j, arr = [0], arrL, i = 0, strL = str.length;\n      for (; i < strL; ) {\n        for (arrL = arr.length; arrL--; )\n          arr[arrL] *= baseIn;\n        arr[0] += NUMERALS.indexOf(str.charAt(i++));\n        for (j = 0; j < arr.length; j++) {\n          if (arr[j] > baseOut - 1) {\n            if (arr[j + 1] === void 0)\n              arr[j + 1] = 0;\n            arr[j + 1] += arr[j] / baseOut | 0;\n            arr[j] %= baseOut;\n          }\n        }\n      }\n      return arr.reverse();\n    }\n    function cosine(Ctor, x) {\n      var k, y, len = x.d.length;\n      if (len < 32) {\n        k = Math.ceil(len / 3);\n        y = (1 / tinyPow(4, k)).toString();\n      } else {\n        k = 16;\n        y = \"2.3283064365386962890625e-10\";\n      }\n      Ctor.precision += k;\n      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n      for (var i = k; i--; ) {\n        var cos2x = x.times(x);\n        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n      }\n      Ctor.precision -= k;\n      return x;\n    }\n    var divide = function() {\n      function multiplyInteger(x, k, base) {\n        var temp, carry = 0, i = x.length;\n        for (x = x.slice(); i--; ) {\n          temp = x[i] * k + carry;\n          x[i] = temp % base | 0;\n          carry = temp / base | 0;\n        }\n        if (carry)\n          x.unshift(carry);\n        return x;\n      }\n      function compare(a, b, aL, bL) {\n        var i, r;\n        if (aL != bL) {\n          r = aL > bL ? 1 : -1;\n        } else {\n          for (i = r = 0; i < aL; i++) {\n            if (a[i] != b[i]) {\n              r = a[i] > b[i] ? 1 : -1;\n              break;\n            }\n          }\n        }\n        return r;\n      }\n      function subtract(a, b, aL, base) {\n        var i = 0;\n        for (; aL--; ) {\n          a[aL] -= i;\n          i = a[aL] < b[aL] ? 1 : 0;\n          a[aL] = i * base + a[aL] - b[aL];\n        }\n        for (; !a[0] && a.length > 1; )\n          a.shift();\n      }\n      return function(x, y, pr, rm, dp, base) {\n        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n          return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);\n        }\n        if (base) {\n          logBase = 1;\n          e = x.e - y.e;\n        } else {\n          base = BASE;\n          logBase = LOG_BASE;\n          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n        }\n        yL = yd.length;\n        xL = xd.length;\n        q = new Ctor(sign2);\n        qd = q.d = [];\n        for (i = 0; yd[i] == (xd[i] || 0); i++)\n          ;\n        if (yd[i] > (xd[i] || 0))\n          e--;\n        if (pr == null) {\n          sd = pr = Ctor.precision;\n          rm = Ctor.rounding;\n        } else if (dp) {\n          sd = pr + (x.e - y.e) + 1;\n        } else {\n          sd = pr;\n        }\n        if (sd < 0) {\n          qd.push(1);\n          more = true;\n        } else {\n          sd = sd / logBase + 2 | 0;\n          i = 0;\n          if (yL == 1) {\n            k = 0;\n            yd = yd[0];\n            sd++;\n            for (; (i < xL || k) && sd--; i++) {\n              t = k * base + (xd[i] || 0);\n              qd[i] = t / yd | 0;\n              k = t % yd | 0;\n            }\n            more = k || i < xL;\n          } else {\n            k = base / (yd[0] + 1) | 0;\n            if (k > 1) {\n              yd = multiplyInteger(yd, k, base);\n              xd = multiplyInteger(xd, k, base);\n              yL = yd.length;\n              xL = xd.length;\n            }\n            xi = yL;\n            rem = xd.slice(0, yL);\n            remL = rem.length;\n            for (; remL < yL; )\n              rem[remL++] = 0;\n            yz = yd.slice();\n            yz.unshift(0);\n            yd0 = yd[0];\n            if (yd[1] >= base / 2)\n              ++yd0;\n            do {\n              k = 0;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 0) {\n                rem0 = rem[0];\n                if (yL != remL)\n                  rem0 = rem0 * base + (rem[1] || 0);\n                k = rem0 / yd0 | 0;\n                if (k > 1) {\n                  if (k >= base)\n                    k = base - 1;\n                  prod = multiplyInteger(yd, k, base);\n                  prodL = prod.length;\n                  remL = rem.length;\n                  cmp = compare(prod, rem, prodL, remL);\n                  if (cmp == 1) {\n                    k--;\n                    subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                  }\n                } else {\n                  if (k == 0)\n                    cmp = k = 1;\n                  prod = yd.slice();\n                }\n                prodL = prod.length;\n                if (prodL < remL)\n                  prod.unshift(0);\n                subtract(rem, prod, remL, base);\n                if (cmp == -1) {\n                  remL = rem.length;\n                  cmp = compare(yd, rem, yL, remL);\n                  if (cmp < 1) {\n                    k++;\n                    subtract(rem, yL < remL ? yz : yd, remL, base);\n                  }\n                }\n                remL = rem.length;\n              } else if (cmp === 0) {\n                k++;\n                rem = [0];\n              }\n              qd[i++] = k;\n              if (cmp && rem[0]) {\n                rem[remL++] = xd[xi] || 0;\n              } else {\n                rem = [xd[xi]];\n                remL = 1;\n              }\n            } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n            more = rem[0] !== void 0;\n          }\n          if (!qd[0])\n            qd.shift();\n        }\n        if (logBase == 1) {\n          q.e = e;\n          inexact = more;\n        } else {\n          for (i = 1, k = qd[0]; k >= 10; k /= 10)\n            i++;\n          q.e = i + e * logBase - 1;\n          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n        }\n        return q;\n      };\n    }();\n    function finalise(x, sd, rm, isTruncated) {\n      var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n      out:\n        if (sd != null) {\n          xd = x.d;\n          if (!xd)\n            return x;\n          for (digits = 1, k = xd[0]; k >= 10; k /= 10)\n            digits++;\n          i = sd - digits;\n          if (i < 0) {\n            i += LOG_BASE;\n            j = sd;\n            w = xd[xdi = 0];\n            rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n          } else {\n            xdi = Math.ceil((i + 1) / LOG_BASE);\n            k = xd.length;\n            if (xdi >= k) {\n              if (isTruncated) {\n                for (; k++ <= xdi; )\n                  xd.push(0);\n                w = rd = 0;\n                digits = 1;\n                i %= LOG_BASE;\n                j = i - LOG_BASE + 1;\n              } else {\n                break out;\n              }\n            } else {\n              w = k = xd[xdi];\n              for (digits = 1; k >= 10; k /= 10)\n                digits++;\n              i %= LOG_BASE;\n              j = i - LOG_BASE + digits;\n              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n            }\n          }\n          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n          if (sd < 1 || !xd[0]) {\n            xd.length = 0;\n            if (roundUp) {\n              sd -= x.e + 1;\n              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n              x.e = -sd || 0;\n            } else {\n              xd[0] = x.e = 0;\n            }\n            return x;\n          }\n          if (i == 0) {\n            xd.length = xdi;\n            k = 1;\n            xdi--;\n          } else {\n            xd.length = xdi + 1;\n            k = mathpow(10, LOG_BASE - i);\n            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n          }\n          if (roundUp) {\n            for (; ; ) {\n              if (xdi == 0) {\n                for (i = 1, j = xd[0]; j >= 10; j /= 10)\n                  i++;\n                j = xd[0] += k;\n                for (k = 1; j >= 10; j /= 10)\n                  k++;\n                if (i != k) {\n                  x.e++;\n                  if (xd[0] == BASE)\n                    xd[0] = 1;\n                }\n                break;\n              } else {\n                xd[xdi] += k;\n                if (xd[xdi] != BASE)\n                  break;\n                xd[xdi--] = 0;\n                k = 1;\n              }\n            }\n          }\n          for (i = xd.length; xd[--i] === 0; )\n            xd.pop();\n        }\n      if (external) {\n        if (x.e > Ctor.maxE) {\n          x.d = null;\n          x.e = NaN;\n        } else if (x.e < Ctor.minE) {\n          x.e = 0;\n          x.d = [0];\n        }\n      }\n      return x;\n    }\n    function finiteToString(x, isExp, sd) {\n      if (!x.isFinite())\n        return nonFiniteToString(x);\n      var k, e = x.e, str = digitsToString(x.d), len = str.length;\n      if (isExp) {\n        if (sd && (k = sd - len) > 0) {\n          str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n        } else if (len > 1) {\n          str = str.charAt(0) + \".\" + str.slice(1);\n        }\n        str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n      } else if (e < 0) {\n        str = \"0.\" + getZeroString(-e - 1) + str;\n        if (sd && (k = sd - len) > 0)\n          str += getZeroString(k);\n      } else if (e >= len) {\n        str += getZeroString(e + 1 - len);\n        if (sd && (k = sd - e - 1) > 0)\n          str = str + \".\" + getZeroString(k);\n      } else {\n        if ((k = e + 1) < len)\n          str = str.slice(0, k) + \".\" + str.slice(k);\n        if (sd && (k = sd - len) > 0) {\n          if (e + 1 === len)\n            str += \".\";\n          str += getZeroString(k);\n        }\n      }\n      return str;\n    }\n    function getBase10Exponent(digits, e) {\n      var w = digits[0];\n      for (e *= LOG_BASE; w >= 10; w /= 10)\n        e++;\n      return e;\n    }\n    function getLn10(Ctor, sd, pr) {\n      if (sd > LN10_PRECISION) {\n        external = true;\n        if (pr)\n          Ctor.precision = pr;\n        throw Error(precisionLimitExceeded);\n      }\n      return finalise(new Ctor(LN10), sd, 1, true);\n    }\n    function getPi(Ctor, sd, rm) {\n      if (sd > PI_PRECISION)\n        throw Error(precisionLimitExceeded);\n      return finalise(new Ctor(PI), sd, rm, true);\n    }\n    function getPrecision(digits) {\n      var w = digits.length - 1, len = w * LOG_BASE + 1;\n      w = digits[w];\n      if (w) {\n        for (; w % 10 == 0; w /= 10)\n          len--;\n        for (w = digits[0]; w >= 10; w /= 10)\n          len++;\n      }\n      return len;\n    }\n    function getZeroString(k) {\n      var zs = \"\";\n      for (; k--; )\n        zs += \"0\";\n      return zs;\n    }\n    function intPow(Ctor, x, n, pr) {\n      var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n      external = false;\n      for (; ; ) {\n        if (n % 2) {\n          r = r.times(x);\n          if (truncate(r.d, k))\n            isTruncated = true;\n        }\n        n = mathfloor(n / 2);\n        if (n === 0) {\n          n = r.d.length - 1;\n          if (isTruncated && r.d[n] === 0)\n            ++r.d[n];\n          break;\n        }\n        x = x.times(x);\n        truncate(x.d, k);\n      }\n      external = true;\n      return r;\n    }\n    function isOdd(n) {\n      return n.d[n.d.length - 1] & 1;\n    }\n    function maxOrMin(Ctor, args, ltgt) {\n      var y, x = new Ctor(args[0]), i = 0;\n      for (; ++i < args.length; ) {\n        y = new Ctor(args[i]);\n        if (!y.s) {\n          x = y;\n          break;\n        } else if (x[ltgt](y)) {\n          x = y;\n        }\n      }\n      return x;\n    }\n    function naturalExponential(x, sd) {\n      var denominator, guard, j, pow2, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n      if (!x.d || !x.d[0] || x.e > 17) {\n        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n      }\n      if (sd == null) {\n        external = false;\n        wpr = pr;\n      } else {\n        wpr = sd;\n      }\n      t = new Ctor(0.03125);\n      while (x.e > -2) {\n        x = x.times(t);\n        k += 5;\n      }\n      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n      wpr += guard;\n      denominator = pow2 = sum = new Ctor(1);\n      Ctor.precision = wpr;\n      for (; ; ) {\n        pow2 = finalise(pow2.times(x), wpr, 1);\n        denominator = denominator.times(++i);\n        t = sum.plus(divide(pow2, denominator, wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n          j = k;\n          while (j--)\n            sum = finalise(sum.times(sum), wpr, 1);\n          if (sd == null) {\n            if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n              Ctor.precision = wpr += 10;\n              denominator = pow2 = t = new Ctor(1);\n              i = 0;\n              rep++;\n            } else {\n              return finalise(sum, Ctor.precision = pr, rm, external = true);\n            }\n          } else {\n            Ctor.precision = pr;\n            return sum;\n          }\n        }\n        sum = t;\n      }\n    }\n    function naturalLogarithm(y, sd) {\n      var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n      }\n      if (sd == null) {\n        external = false;\n        wpr = pr;\n      } else {\n        wpr = sd;\n      }\n      Ctor.precision = wpr += guard;\n      c = digitsToString(xd);\n      c0 = c.charAt(0);\n      if (Math.abs(e = x.e) < 15e14) {\n        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n          x = x.times(y);\n          c = digitsToString(x.d);\n          c0 = c.charAt(0);\n          n++;\n        }\n        e = x.e;\n        if (c0 > 1) {\n          x = new Ctor(\"0.\" + c);\n          e++;\n        } else {\n          x = new Ctor(c0 + \".\" + c.slice(1));\n        }\n      } else {\n        t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n        x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n        Ctor.precision = pr;\n        return sd == null ? finalise(x, pr, rm, external = true) : x;\n      }\n      x1 = x;\n      sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n      x2 = finalise(x.times(x), wpr, 1);\n      denominator = 3;\n      for (; ; ) {\n        numerator = finalise(numerator.times(x2), wpr, 1);\n        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n          sum = sum.times(2);\n          if (e !== 0)\n            sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n          sum = divide(sum, new Ctor(n), wpr, 1);\n          if (sd == null) {\n            if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n              Ctor.precision = wpr += guard;\n              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n              x2 = finalise(x.times(x), wpr, 1);\n              denominator = rep = 1;\n            } else {\n              return finalise(sum, Ctor.precision = pr, rm, external = true);\n            }\n          } else {\n            Ctor.precision = pr;\n            return sum;\n          }\n        }\n        sum = t;\n        denominator += 2;\n      }\n    }\n    function nonFiniteToString(x) {\n      return String(x.s * x.s / 0);\n    }\n    function parseDecimal(x, str) {\n      var e, i, len;\n      if ((e = str.indexOf(\".\")) > -1)\n        str = str.replace(\".\", \"\");\n      if ((i = str.search(/e/i)) > 0) {\n        if (e < 0)\n          e = i;\n        e += +str.slice(i + 1);\n        str = str.substring(0, i);\n      } else if (e < 0) {\n        e = str.length;\n      }\n      for (i = 0; str.charCodeAt(i) === 48; i++)\n        ;\n      for (len = str.length; str.charCodeAt(len - 1) === 48; --len)\n        ;\n      str = str.slice(i, len);\n      if (str) {\n        len -= i;\n        x.e = e = e - i - 1;\n        x.d = [];\n        i = (e + 1) % LOG_BASE;\n        if (e < 0)\n          i += LOG_BASE;\n        if (i < len) {\n          if (i)\n            x.d.push(+str.slice(0, i));\n          for (len -= LOG_BASE; i < len; )\n            x.d.push(+str.slice(i, i += LOG_BASE));\n          str = str.slice(i);\n          i = LOG_BASE - str.length;\n        } else {\n          i -= len;\n        }\n        for (; i--; )\n          str += \"0\";\n        x.d.push(+str);\n        if (external) {\n          if (x.e > x.constructor.maxE) {\n            x.d = null;\n            x.e = NaN;\n          } else if (x.e < x.constructor.minE) {\n            x.e = 0;\n            x.d = [0];\n          }\n        }\n      } else {\n        x.e = 0;\n        x.d = [0];\n      }\n      return x;\n    }\n    function parseOther(x, str) {\n      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n      if (str === \"Infinity\" || str === \"NaN\") {\n        if (!+str)\n          x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return x;\n      }\n      if (isHex.test(str)) {\n        base = 16;\n        str = str.toLowerCase();\n      } else if (isBinary.test(str)) {\n        base = 2;\n      } else if (isOctal.test(str)) {\n        base = 8;\n      } else {\n        throw Error(invalidArgument + str);\n      }\n      i = str.search(/p/i);\n      if (i > 0) {\n        p = +str.slice(i + 1);\n        str = str.substring(2, i);\n      } else {\n        str = str.slice(2);\n      }\n      i = str.indexOf(\".\");\n      isFloat = i >= 0;\n      Ctor = x.constructor;\n      if (isFloat) {\n        str = str.replace(\".\", \"\");\n        len = str.length;\n        i = len - i;\n        divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n      }\n      xd = convertBase(str, base, BASE);\n      xe = xd.length - 1;\n      for (i = xe; xd[i] === 0; --i)\n        xd.pop();\n      if (i < 0)\n        return new Ctor(x.s * 0);\n      x.e = getBase10Exponent(xd, xe);\n      x.d = xd;\n      external = false;\n      if (isFloat)\n        x = divide(x, divisor, len * 4);\n      if (p)\n        x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n      external = true;\n      return x;\n    }\n    function sine(Ctor, x) {\n      var k, len = x.d.length;\n      if (len < 3)\n        return taylorSeries(Ctor, 2, x, x);\n      k = 1.4 * Math.sqrt(len);\n      k = k > 16 ? 16 : k | 0;\n      x = x.times(1 / tinyPow(5, k));\n      x = taylorSeries(Ctor, 2, x, x);\n      var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n      for (; k--; ) {\n        sin2_x = x.times(x);\n        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n      }\n      return x;\n    }\n    function taylorSeries(Ctor, n, x, y, isHyperbolic) {\n      var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n      external = false;\n      x2 = x.times(x);\n      u = new Ctor(y);\n      for (; ; ) {\n        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n        u = isHyperbolic ? y.plus(t) : y.minus(t);\n        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n        t = u.plus(y);\n        if (t.d[k] !== void 0) {\n          for (j = k; t.d[j] === u.d[j] && j--; )\n            ;\n          if (j == -1)\n            break;\n        }\n        j = u;\n        u = y;\n        y = t;\n        t = j;\n        i++;\n      }\n      external = true;\n      t.d.length = k + 1;\n      return t;\n    }\n    function tinyPow(b, e) {\n      var n = b;\n      while (--e)\n        n *= b;\n      return n;\n    }\n    function toLessThanHalfPi(Ctor, x) {\n      var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n      x = x.abs();\n      if (x.lte(halfPi)) {\n        quadrant = isNeg ? 4 : 1;\n        return x;\n      }\n      t = x.divToInt(pi);\n      if (t.isZero()) {\n        quadrant = isNeg ? 3 : 2;\n      } else {\n        x = x.minus(t.times(pi));\n        if (x.lte(halfPi)) {\n          quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n          return x;\n        }\n        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n      }\n      return x.minus(pi).abs();\n    }\n    function toStringBinary(x, baseOut, sd, rm) {\n      var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n      if (isExp) {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0)\n          rm = Ctor.rounding;\n        else\n          checkInt32(rm, 0, 8);\n      } else {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n      }\n      if (!x.isFinite()) {\n        str = nonFiniteToString(x);\n      } else {\n        str = finiteToString(x);\n        i = str.indexOf(\".\");\n        if (isExp) {\n          base = 2;\n          if (baseOut == 16) {\n            sd = sd * 4 - 3;\n          } else if (baseOut == 8) {\n            sd = sd * 3 - 2;\n          }\n        } else {\n          base = baseOut;\n        }\n        if (i >= 0) {\n          str = str.replace(\".\", \"\");\n          y = new Ctor(1);\n          y.e = str.length - i;\n          y.d = convertBase(finiteToString(y), 10, base);\n          y.e = y.d.length;\n        }\n        xd = convertBase(str, 10, base);\n        e = len = xd.length;\n        for (; xd[--len] == 0; )\n          xd.pop();\n        if (!xd[0]) {\n          str = isExp ? \"0p+0\" : \"0\";\n        } else {\n          if (i < 0) {\n            e--;\n          } else {\n            x = new Ctor(x);\n            x.d = xd;\n            x.e = e;\n            x = divide(x, y, sd, rm, 0, base);\n            xd = x.d;\n            e = x.e;\n            roundUp = inexact;\n          }\n          i = xd[sd];\n          k = base / 2;\n          roundUp = roundUp || xd[sd + 1] !== void 0;\n          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n          xd.length = sd;\n          if (roundUp) {\n            for (; ++xd[--sd] > base - 1; ) {\n              xd[sd] = 0;\n              if (!sd) {\n                ++e;\n                xd.unshift(1);\n              }\n            }\n          }\n          for (len = xd.length; !xd[len - 1]; --len)\n            ;\n          for (i = 0, str = \"\"; i < len; i++)\n            str += NUMERALS.charAt(xd[i]);\n          if (isExp) {\n            if (len > 1) {\n              if (baseOut == 16 || baseOut == 8) {\n                i = baseOut == 16 ? 4 : 3;\n                for (--len; len % i; len++)\n                  str += \"0\";\n                xd = convertBase(str, base, baseOut);\n                for (len = xd.length; !xd[len - 1]; --len)\n                  ;\n                for (i = 1, str = \"1.\"; i < len; i++)\n                  str += NUMERALS.charAt(xd[i]);\n              } else {\n                str = str.charAt(0) + \".\" + str.slice(1);\n              }\n            }\n            str = str + (e < 0 ? \"p\" : \"p+\") + e;\n          } else if (e < 0) {\n            for (; ++e; )\n              str = \"0\" + str;\n            str = \"0.\" + str;\n          } else {\n            if (++e > len)\n              for (e -= len; e--; )\n                str += \"0\";\n            else if (e < len)\n              str = str.slice(0, e) + \".\" + str.slice(e);\n          }\n        }\n        str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n      }\n      return x.s < 0 ? \"-\" + str : str;\n    }\n    function truncate(arr, len) {\n      if (arr.length > len) {\n        arr.length = len;\n        return true;\n      }\n    }\n    function abs(x) {\n      return new this(x).abs();\n    }\n    function acos(x) {\n      return new this(x).acos();\n    }\n    function acosh(x) {\n      return new this(x).acosh();\n    }\n    function add(x, y) {\n      return new this(x).plus(y);\n    }\n    function asin(x) {\n      return new this(x).asin();\n    }\n    function asinh(x) {\n      return new this(x).asinh();\n    }\n    function atan(x) {\n      return new this(x).atan();\n    }\n    function atanh(x) {\n      return new this(x).atanh();\n    }\n    function atan2(y, x) {\n      y = new this(y);\n      x = new this(x);\n      var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n      if (!y.s || !x.s) {\n        r = new this(NaN);\n      } else if (!y.d && !x.d) {\n        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n        r.s = y.s;\n      } else if (!x.d || y.isZero()) {\n        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n        r.s = y.s;\n      } else if (!y.d || x.isZero()) {\n        r = getPi(this, wpr, 1).times(0.5);\n        r.s = y.s;\n      } else if (x.s < 0) {\n        this.precision = wpr;\n        this.rounding = 1;\n        r = this.atan(divide(y, x, wpr, 1));\n        x = getPi(this, wpr, 1);\n        this.precision = pr;\n        this.rounding = rm;\n        r = y.s < 0 ? r.minus(x) : r.plus(x);\n      } else {\n        r = this.atan(divide(y, x, wpr, 1));\n      }\n      return r;\n    }\n    function cbrt(x) {\n      return new this(x).cbrt();\n    }\n    function ceil(x) {\n      return finalise(x = new this(x), x.e + 1, 2);\n    }\n    function config(obj) {\n      if (!obj || typeof obj !== \"object\")\n        throw Error(decimalError + \"Object expected\");\n      var i, p, v, useDefaults = obj.defaults === true, ps = [\n        \"precision\",\n        1,\n        MAX_DIGITS,\n        \"rounding\",\n        0,\n        8,\n        \"toExpNeg\",\n        -EXP_LIMIT,\n        0,\n        \"toExpPos\",\n        0,\n        EXP_LIMIT,\n        \"maxE\",\n        0,\n        EXP_LIMIT,\n        \"minE\",\n        -EXP_LIMIT,\n        0,\n        \"modulo\",\n        0,\n        9\n      ];\n      for (i = 0; i < ps.length; i += 3) {\n        if (p = ps[i], useDefaults)\n          this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])\n            this[p] = v;\n          else\n            throw Error(invalidArgument + p + \": \" + v);\n        }\n      }\n      if (p = \"crypto\", useDefaults)\n        this[p] = DEFAULTS[p];\n      if ((v = obj[p]) !== void 0) {\n        if (v === true || v === false || v === 0 || v === 1) {\n          if (v) {\n            if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n              this[p] = true;\n            } else {\n              throw Error(cryptoUnavailable);\n            }\n          } else {\n            this[p] = false;\n          }\n        } else {\n          throw Error(invalidArgument + p + \": \" + v);\n        }\n      }\n      return this;\n    }\n    function cos(x) {\n      return new this(x).cos();\n    }\n    function cosh(x) {\n      return new this(x).cosh();\n    }\n    function clone(obj) {\n      var i, p, ps;\n      function Decimal2(v) {\n        var e, i2, t, x = this;\n        if (!(x instanceof Decimal2))\n          return new Decimal2(v);\n        x.constructor = Decimal2;\n        if (v instanceof Decimal2) {\n          x.s = v.s;\n          if (external) {\n            if (!v.d || v.e > Decimal2.maxE) {\n              x.e = NaN;\n              x.d = null;\n            } else if (v.e < Decimal2.minE) {\n              x.e = 0;\n              x.d = [0];\n            } else {\n              x.e = v.e;\n              x.d = v.d.slice();\n            }\n          } else {\n            x.e = v.e;\n            x.d = v.d ? v.d.slice() : v.d;\n          }\n          return;\n        }\n        t = typeof v;\n        if (t === \"number\") {\n          if (v === 0) {\n            x.s = 1 / v < 0 ? -1 : 1;\n            x.e = 0;\n            x.d = [0];\n            return;\n          }\n          if (v < 0) {\n            v = -v;\n            x.s = -1;\n          } else {\n            x.s = 1;\n          }\n          if (v === ~~v && v < 1e7) {\n            for (e = 0, i2 = v; i2 >= 10; i2 /= 10)\n              e++;\n            if (external) {\n              if (e > Decimal2.maxE) {\n                x.e = NaN;\n                x.d = null;\n              } else if (e < Decimal2.minE) {\n                x.e = 0;\n                x.d = [0];\n              } else {\n                x.e = e;\n                x.d = [v];\n              }\n            } else {\n              x.e = e;\n              x.d = [v];\n            }\n            return;\n          } else if (v * 0 !== 0) {\n            if (!v)\n              x.s = NaN;\n            x.e = NaN;\n            x.d = null;\n            return;\n          }\n          return parseDecimal(x, v.toString());\n        } else if (t !== \"string\") {\n          throw Error(invalidArgument + v);\n        }\n        if ((i2 = v.charCodeAt(0)) === 45) {\n          v = v.slice(1);\n          x.s = -1;\n        } else {\n          if (i2 === 43)\n            v = v.slice(1);\n          x.s = 1;\n        }\n        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n      }\n      Decimal2.prototype = P;\n      Decimal2.ROUND_UP = 0;\n      Decimal2.ROUND_DOWN = 1;\n      Decimal2.ROUND_CEIL = 2;\n      Decimal2.ROUND_FLOOR = 3;\n      Decimal2.ROUND_HALF_UP = 4;\n      Decimal2.ROUND_HALF_DOWN = 5;\n      Decimal2.ROUND_HALF_EVEN = 6;\n      Decimal2.ROUND_HALF_CEIL = 7;\n      Decimal2.ROUND_HALF_FLOOR = 8;\n      Decimal2.EUCLID = 9;\n      Decimal2.config = Decimal2.set = config;\n      Decimal2.clone = clone;\n      Decimal2.isDecimal = isDecimalInstance;\n      Decimal2.abs = abs;\n      Decimal2.acos = acos;\n      Decimal2.acosh = acosh;\n      Decimal2.add = add;\n      Decimal2.asin = asin;\n      Decimal2.asinh = asinh;\n      Decimal2.atan = atan;\n      Decimal2.atanh = atanh;\n      Decimal2.atan2 = atan2;\n      Decimal2.cbrt = cbrt;\n      Decimal2.ceil = ceil;\n      Decimal2.cos = cos;\n      Decimal2.cosh = cosh;\n      Decimal2.div = div;\n      Decimal2.exp = exp;\n      Decimal2.floor = floor;\n      Decimal2.hypot = hypot;\n      Decimal2.ln = ln;\n      Decimal2.log = log;\n      Decimal2.log10 = log10;\n      Decimal2.log2 = log2;\n      Decimal2.max = max;\n      Decimal2.min = min;\n      Decimal2.mod = mod;\n      Decimal2.mul = mul;\n      Decimal2.pow = pow;\n      Decimal2.random = random;\n      Decimal2.round = round;\n      Decimal2.sign = sign;\n      Decimal2.sin = sin;\n      Decimal2.sinh = sinh;\n      Decimal2.sqrt = sqrt;\n      Decimal2.sub = sub;\n      Decimal2.tan = tan;\n      Decimal2.tanh = tanh;\n      Decimal2.trunc = trunc;\n      if (obj === void 0)\n        obj = {};\n      if (obj) {\n        if (obj.defaults !== true) {\n          ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n          for (i = 0; i < ps.length; )\n            if (!obj.hasOwnProperty(p = ps[i++]))\n              obj[p] = this[p];\n        }\n      }\n      Decimal2.config(obj);\n      return Decimal2;\n    }\n    function div(x, y) {\n      return new this(x).div(y);\n    }\n    function exp(x) {\n      return new this(x).exp();\n    }\n    function floor(x) {\n      return finalise(x = new this(x), x.e + 1, 3);\n    }\n    function hypot() {\n      var i, n, t = new this(0);\n      external = false;\n      for (i = 0; i < arguments.length; ) {\n        n = new this(arguments[i++]);\n        if (!n.d) {\n          if (n.s) {\n            external = true;\n            return new this(1 / 0);\n          }\n          t = n;\n        } else if (t.d) {\n          t = t.plus(n.times(n));\n        }\n      }\n      external = true;\n      return t.sqrt();\n    }\n    function isDecimalInstance(obj) {\n      return obj instanceof Decimal || obj && obj.name === \"[object Decimal]\" || false;\n    }\n    function ln(x) {\n      return new this(x).ln();\n    }\n    function log(x, y) {\n      return new this(x).log(y);\n    }\n    function log2(x) {\n      return new this(x).log(2);\n    }\n    function log10(x) {\n      return new this(x).log(10);\n    }\n    function max() {\n      return maxOrMin(this, arguments, \"lt\");\n    }\n    function min() {\n      return maxOrMin(this, arguments, \"gt\");\n    }\n    function mod(x, y) {\n      return new this(x).mod(y);\n    }\n    function mul(x, y) {\n      return new this(x).mul(y);\n    }\n    function pow(x, y) {\n      return new this(x).pow(y);\n    }\n    function random(sd) {\n      var d, e, k, n, i = 0, r = new this(1), rd = [];\n      if (sd === void 0)\n        sd = this.precision;\n      else\n        checkInt32(sd, 1, MAX_DIGITS);\n      k = Math.ceil(sd / LOG_BASE);\n      if (!this.crypto) {\n        for (; i < k; )\n          rd[i++] = Math.random() * 1e7 | 0;\n      } else if (crypto.getRandomValues) {\n        d = crypto.getRandomValues(new Uint32Array(k));\n        for (; i < k; ) {\n          n = d[i];\n          if (n >= 429e7) {\n            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n          } else {\n            rd[i++] = n % 1e7;\n          }\n        }\n      } else if (crypto.randomBytes) {\n        d = crypto.randomBytes(k *= 4);\n        for (; i < k; ) {\n          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n          if (n >= 214e7) {\n            crypto.randomBytes(4).copy(d, i);\n          } else {\n            rd.push(n % 1e7);\n            i += 4;\n          }\n        }\n        i = k / 4;\n      } else {\n        throw Error(cryptoUnavailable);\n      }\n      k = rd[--i];\n      sd %= LOG_BASE;\n      if (k && sd) {\n        n = mathpow(10, LOG_BASE - sd);\n        rd[i] = (k / n | 0) * n;\n      }\n      for (; rd[i] === 0; i--)\n        rd.pop();\n      if (i < 0) {\n        e = 0;\n        rd = [0];\n      } else {\n        e = -1;\n        for (; rd[0] === 0; e -= LOG_BASE)\n          rd.shift();\n        for (k = 1, n = rd[0]; n >= 10; n /= 10)\n          k++;\n        if (k < LOG_BASE)\n          e -= LOG_BASE - k;\n      }\n      r.e = e;\n      r.d = rd;\n      return r;\n    }\n    function round(x) {\n      return finalise(x = new this(x), x.e + 1, this.rounding);\n    }\n    function sign(x) {\n      x = new this(x);\n      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n    }\n    function sin(x) {\n      return new this(x).sin();\n    }\n    function sinh(x) {\n      return new this(x).sinh();\n    }\n    function sqrt(x) {\n      return new this(x).sqrt();\n    }\n    function sub(x, y) {\n      return new this(x).sub(y);\n    }\n    function tan(x) {\n      return new this(x).tan();\n    }\n    function tanh(x) {\n      return new this(x).tanh();\n    }\n    function trunc(x) {\n      return finalise(x = new this(x), x.e + 1, 1);\n    }\n    Decimal = clone(DEFAULTS);\n    Decimal[\"default\"] = Decimal.Decimal = Decimal;\n    LN10 = new Decimal(LN10);\n    PI = new Decimal(PI);\n    if (true) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Decimal;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(exports2);\n});\n\n// src/runtime/index-browser.ts\n__export(exports, {\n  Decimal: () => decimal.default\n});\nvar decimal = __toModule(require_decimal());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50L3J1bnRpbWUvaW5kZXgtYnJvd3Nlci5qcz9kZjdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpR0FBaUc7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWMsaUNBQWlDO0FBQ3JJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5cUJBQXlxQjtBQUM5cUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXlDO0FBQ2pELE1BQU0sbUNBQU87QUFDYjtBQUNBLE9BQU87QUFBQSxvR0FBQztBQUNSLEtBQUssTUFBTSxFQWdCTjtBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4LWJyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xudmFyIF9fY29tbW9uSlMgPSAoY2FsbGJhY2ssIG1vZHVsZTIpID0+ICgpID0+IHtcbiAgaWYgKCFtb2R1bGUyKSB7XG4gICAgbW9kdWxlMiA9IHtleHBvcnRzOiB7fX07XG4gICAgY2FsbGJhY2sobW9kdWxlMi5leHBvcnRzLCBtb2R1bGUyKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlMi5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7Z2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWV9KTtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7Z2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSlcbiAgICByZXR1cm4gbW9kdWxlMjtcbiAgcmV0dXJuIF9fZXhwb3J0U3RhcihfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwge3ZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlfSksIG1vZHVsZTIpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlY2ltYWwuanNAMTAuMi4xL25vZGVfbW9kdWxlcy9kZWNpbWFsLmpzL2RlY2ltYWwuanNcbnZhciByZXF1aXJlX2RlY2ltYWwgPSBfX2NvbW1vbkpTKChleHBvcnRzMiwgbW9kdWxlMikgPT4ge1xuICAoZnVuY3Rpb24oZ2xvYmFsU2NvcGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgRVhQX0xJTUlUID0gOWUxNSwgTUFYX0RJR0lUUyA9IDFlOSwgTlVNRVJBTFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgTE4xMCA9IFwiMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4XCIsIFBJID0gXCIzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODlcIiwgREVGQVVMVFMgPSB7XG4gICAgICBwcmVjaXNpb246IDIwLFxuICAgICAgcm91bmRpbmc6IDQsXG4gICAgICBtb2R1bG86IDEsXG4gICAgICB0b0V4cE5lZzogLTcsXG4gICAgICB0b0V4cFBvczogMjEsXG4gICAgICBtaW5FOiAtRVhQX0xJTUlULFxuICAgICAgbWF4RTogRVhQX0xJTUlULFxuICAgICAgY3J5cHRvOiBmYWxzZVxuICAgIH0sIERlY2ltYWwsIGluZXhhY3QsIG5vQ29uZmxpY3QsIHF1YWRyYW50LCBleHRlcm5hbCA9IHRydWUsIGRlY2ltYWxFcnJvciA9IFwiW0RlY2ltYWxFcnJvcl0gXCIsIGludmFsaWRBcmd1bWVudCA9IGRlY2ltYWxFcnJvciArIFwiSW52YWxpZCBhcmd1bWVudDogXCIsIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyBcIlByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiLCBjcnlwdG9VbmF2YWlsYWJsZSA9IGRlY2ltYWxFcnJvciArIFwiY3J5cHRvIHVuYXZhaWxhYmxlXCIsIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsIG1hdGhwb3cgPSBNYXRoLnBvdywgaXNCaW5hcnkgPSAvXjBiKFswMV0rKFxcLlswMV0qKT98XFwuWzAxXSspKHBbKy1dP1xcZCspPyQvaSwgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSwgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pLCBpc0RlY2ltYWwgPSAvXihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2ksIEJBU0UgPSAxZTcsIExPR19CQVNFID0gNywgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsIExOMTBfUFJFQ0lTSU9OID0gTE4xMC5sZW5ndGggLSAxLCBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxLCBQID0ge25hbWU6IFwiW29iamVjdCBEZWNpbWFsXVwifTtcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIGlmICh4LnMgPCAwKVxuICAgICAgICB4LnMgPSAxO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHgpO1xuICAgIH07XG4gICAgUC5jZWlsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xuICAgIH07XG4gICAgUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgaSwgaiwgeGRMLCB5ZEwsIHggPSB0aGlzLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLCB4cyA9IHgucywgeXMgPSB5LnM7XG4gICAgICBpZiAoIXhkIHx8ICF5ZCkge1xuICAgICAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICgheGRbMF0gfHwgIXlkWzBdKVxuICAgICAgICByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcbiAgICAgIGlmICh4cyAhPT0geXMpXG4gICAgICAgIHJldHVybiB4cztcbiAgICAgIGlmICh4LmUgIT09IHkuZSlcbiAgICAgICAgcmV0dXJuIHguZSA+IHkuZSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgICAgIHhkTCA9IHhkLmxlbmd0aDtcbiAgICAgIHlkTCA9IHlkLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgaWYgKHhkW2ldICE9PSB5ZFtpXSlcbiAgICAgICAgICByZXR1cm4geGRbaV0gPiB5ZFtpXSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4ZEwgPT09IHlkTCA/IDAgOiB4ZEwgPiB5ZEwgXiB4cyA8IDAgPyAxIDogLTE7XG4gICAgfTtcbiAgICBQLmNvc2luZSA9IFAuY29zID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXguZClcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgICBpZiAoIXguZFswXSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKDEpO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgeCA9IGNvc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gcm07XG4gICAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSAzID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSwgbSwgbiwgciwgcmVwLCBzLCBzZCwgdCwgdDMsIHQzcGx1c3gsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICBzID0geC5zICogbWF0aHBvdyh4LnMgKiB4LCAxIC8gMyk7XG4gICAgICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcbiAgICAgICAgbiA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XG4gICAgICAgIGUgPSB4LmU7XG4gICAgICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMylcbiAgICAgICAgICBuICs9IHMgPT0gMSB8fCBzID09IC0yID8gXCIwXCIgOiBcIjAwXCI7XG4gICAgICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcbiAgICAgICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMykgLSAoZSAlIDMgPT0gKGUgPCAwID8gLTEgOiAyKSk7XG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XG4gICAgICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgICAgIH1cbiAgICAgICAgciA9IG5ldyBDdG9yKG4pO1xuICAgICAgICByLnMgPSB4LnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHQgPSByO1xuICAgICAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XG4gICAgICAgIHQzcGx1c3ggPSB0My5wbHVzKHgpO1xuICAgICAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcbiAgICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xuICAgICAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcbiAgICAgICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgICAgIGlmICghcmVwKSB7XG4gICAgICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcbiAgICAgICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgICAgICByID0gdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2QgKz0gNDtcbiAgICAgICAgICAgIHJlcCA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09IFwiNVwiKSB7XG4gICAgICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLnRpbWVzKHIpLmVxKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XG4gICAgfTtcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdywgZCA9IHRoaXMuZCwgbiA9IE5hTjtcbiAgICAgIGlmIChkKSB7XG4gICAgICAgIHcgPSBkLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSAodyAtIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XG4gICAgICAgIHcgPSBkW3ddO1xuICAgICAgICBpZiAodylcbiAgICAgICAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApXG4gICAgICAgICAgICBuLS07XG4gICAgICAgIGlmIChuIDwgMClcbiAgICAgICAgICBuID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xuICAgIH07XG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBmaW5hbGlzZShkaXZpZGUoeCwgbmV3IEN0b3IoeSksIDAsIDEsIDEpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XG4gICAgfTtcbiAgICBQLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAoeSkgPT09IDA7XG4gICAgfTtcbiAgICBQLmZsb29yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDMpO1xuICAgIH07XG4gICAgUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAoeSkgPiAwO1xuICAgIH07XG4gICAgUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIGsgPSB0aGlzLmNtcCh5KTtcbiAgICAgIHJldHVybiBrID09IDEgfHwgayA9PT0gMDtcbiAgICB9O1xuICAgIFAuaHlwZXJib2xpY0Nvc2luZSA9IFAuY29zaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGssIG4sIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIG9uZSA9IG5ldyBDdG9yKDEpO1xuICAgICAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4LnMgPyAxIC8gMCA6IE5hTik7XG4gICAgICBpZiAoeC5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG9uZTtcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgbGVuID0geC5kLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCAzMikge1xuICAgICAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xuICAgICAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9IDE2O1xuICAgICAgICBuID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gICAgICB9XG4gICAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMobiksIG5ldyBDdG9yKDEpLCB0cnVlKTtcbiAgICAgIHZhciBjb3NoMl94LCBpID0gaywgZDggPSBuZXcgQ3Rvcig4KTtcbiAgICAgIGZvciAoOyBpLS07ICkge1xuICAgICAgICBjb3NoMl94ID0geC50aW1lcyh4KTtcbiAgICAgICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmFsaXNlKHgsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQLmh5cGVyYm9saWNTaW5lID0gUC5zaW5oID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaywgcHIsIHJtLCBsZW4sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgbGVuID0geC5kLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCAzKSB7XG4gICAgICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xuICAgICAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gICAgICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XG4gICAgICAgIHZhciBzaW5oMl94LCBkNSA9IG5ldyBDdG9yKDUpLCBkMTYgPSBuZXcgQ3RvcigxNiksIGQyMCA9IG5ldyBDdG9yKDIwKTtcbiAgICAgICAgZm9yICg7IGstLTsgKSB7XG4gICAgICAgICAgc2luaDJfeCA9IHgudGltZXMoeCk7XG4gICAgICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW5oMl94LnRpbWVzKGQxNi50aW1lcyhzaW5oMl94KS5wbHVzKGQyMCkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gcm07XG4gICAgICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcbiAgICB9O1xuICAgIFAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeC5zKTtcbiAgICAgIGlmICh4LmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgICAgIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xuICAgIH07XG4gICAgUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGFsZlBpLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIGsgPSB4LmFicygpLmNtcCgxKSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgaWYgKGsgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBrID09PSAwID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApIDogbmV3IEN0b3IoTmFOKTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzWmVybygpKVxuICAgICAgICByZXR1cm4gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xuICAgICAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gICAgICB4ID0geC5hc2luKCk7XG4gICAgICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgICAgIHJldHVybiBoYWxmUGkubWludXMoeCk7XG4gICAgfTtcbiAgICBQLmludmVyc2VIeXBlcmJvbGljQ29zaW5lID0gUC5hY29zaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKHgubHRlKDEpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeC5lcSgxKSA/IDAgOiBOYU4pO1xuICAgICAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDQ7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICB4ID0geC50aW1lcyh4KS5taW51cygxKS5zcXJ0KCkucGx1cyh4KTtcbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gcm07XG4gICAgICByZXR1cm4geC5sbigpO1xuICAgIH07XG4gICAgUC5pbnZlcnNlSHlwZXJib2xpY1NpbmUgPSBQLmFzaW5oID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDIgKiBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNjtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgIHggPSB4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoeCk7XG4gICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICAgICAgcmV0dXJuIHgubG4oKTtcbiAgICB9O1xuICAgIFAuaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ID0gUC5hdGFuaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByLCBybSwgd3ByLCB4c2QsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICAgIGlmICh4LmUgPj0gMClcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIHhzZCA9IHguc2QoKTtcbiAgICAgIGlmIChNYXRoLm1heCh4c2QsIHByKSA8IDIgKiAteC5lIC0gMSlcbiAgICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XG4gICAgICB4ID0gZGl2aWRlKHgucGx1cygxKSwgbmV3IEN0b3IoMSkubWludXMoeCksIHdwciArIHByLCAxKTtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xuICAgICAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gICAgICB4ID0geC5sbigpO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgICAgIHJldHVybiB4LnRpbWVzKDAuNSk7XG4gICAgfTtcbiAgICBQLmludmVyc2VTaW5lID0gUC5hc2luID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGFsZlBpLCBrLCBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICh4LmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gICAgICBrID0geC5hYnMoKS5jbXAoMSk7XG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgaWYgKGsgIT09IC0xKSB7XG4gICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgICAgICBoYWxmUGkucyA9IHgucztcbiAgICAgICAgICByZXR1cm4gaGFsZlBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgICAgfVxuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XG4gICAgICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgICAgIHggPSB4LmRpdihuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgICAgIHJldHVybiB4LnRpbWVzKDIpO1xuICAgIH07XG4gICAgUC5pbnZlcnNlVGFuZ2VudCA9IFAuYXRhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGosIGssIG4sIHB4LCB0LCByLCB3cHIsIHgyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIGlmICgheC5pc0Zpbml0ZSgpKSB7XG4gICAgICAgIGlmICgheC5zKVxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgICAgICBpZiAocHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgICAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgICAgIHIucyA9IHgucztcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgICAgIH0gZWxzZSBpZiAoeC5hYnMoKS5lcSgxKSAmJiBwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XG4gICAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcbiAgICAgICAgci5zID0geC5zO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcbiAgICAgIGZvciAoaSA9IGs7IGk7IC0taSlcbiAgICAgICAgeCA9IHguZGl2KHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7XG4gICAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgICAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XG4gICAgICBuID0gMTtcbiAgICAgIHgyID0geC50aW1lcyh4KTtcbiAgICAgIHIgPSBuZXcgQ3Rvcih4KTtcbiAgICAgIHB4ID0geDtcbiAgICAgIGZvciAoOyBpICE9PSAtMTsgKSB7XG4gICAgICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgICAgICB0ID0gci5taW51cyhweC5kaXYobiArPSAyKSk7XG4gICAgICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgICAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcbiAgICAgICAgaWYgKHIuZFtqXSAhPT0gdm9pZCAwKVxuICAgICAgICAgIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTsgKVxuICAgICAgICAgICAgO1xuICAgICAgfVxuICAgICAgaWYgKGspXG4gICAgICAgIHIgPSByLnRpbWVzKDIgPDwgayAtIDEpO1xuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmQ7XG4gICAgfTtcbiAgICBQLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XG4gICAgfTtcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMucztcbiAgICB9O1xuICAgIFAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xuICAgIH07XG4gICAgUC5pc1Bvc2l0aXZlID0gUC5pc1BvcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XG4gICAgfTtcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcbiAgICB9O1xuICAgIFAubGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcbiAgICB9O1xuICAgIFAubGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XG4gICAgfTtcbiAgICBQLmxvZ2FyaXRobSA9IFAubG9nID0gZnVuY3Rpb24oYmFzZSkge1xuICAgICAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLCBhcmcgPSB0aGlzLCBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmcsIGd1YXJkID0gNTtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgYmFzZSA9IG5ldyBDdG9yKDEwKTtcbiAgICAgICAgaXNCYXNlMTAgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9IG5ldyBDdG9yKGJhc2UpO1xuICAgICAgICBkID0gYmFzZS5kO1xuICAgICAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKVxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgICAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xuICAgICAgfVxuICAgICAgZCA9IGFyZy5kO1xuICAgICAgaWYgKGFyZy5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBhcmcuZXEoMSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNCYXNlMTApIHtcbiAgICAgICAgaWYgKGQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGluZiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOyApXG4gICAgICAgICAgICBrIC89IDEwO1xuICAgICAgICAgIGluZiA9IGsgIT09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICBzZCA9IHByICsgZ3VhcmQ7XG4gICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xuICAgICAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcbiAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrID0gcHIsIHJtKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc2QgKz0gMTA7XG4gICAgICAgICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xuICAgICAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICAgICAgICAgIGlmICghaW5mKSB7XG4gICAgICAgICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UoayArIDEsIGsgKyAxNSkgKyAxID09IDFlMTQpIHtcbiAgICAgICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrICs9IDEwLCBybSkpO1xuICAgICAgfVxuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG4gICAgfTtcbiAgICBQLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICAgIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucylcbiAgICAgICAgICB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICAgICAgZWxzZSBpZiAoeC5kKVxuICAgICAgICAgIHkucyA9IC15LnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyAhPT0geS5zID8geCA6IE5hTik7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgICAgaWYgKHgucyAhPSB5LnMpIHtcbiAgICAgICAgeS5zID0gLXkucztcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcbiAgICAgIH1cbiAgICAgIHhkID0geC5kO1xuICAgICAgeWQgPSB5LmQ7XG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcbiAgICAgICAgaWYgKHlkWzBdKVxuICAgICAgICAgIHkucyA9IC15LnM7XG4gICAgICAgIGVsc2UgaWYgKHhkWzBdKVxuICAgICAgICAgIHkgPSBuZXcgQ3Rvcih4KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gICAgICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xuICAgICAgfVxuICAgICAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gICAgICB4ZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XG4gICAgICB4ZCA9IHhkLnNsaWNlKCk7XG4gICAgICBrID0geGUgLSBlO1xuICAgICAgaWYgKGspIHtcbiAgICAgICAgeExUeSA9IGsgPCAwO1xuICAgICAgICBpZiAoeExUeSkge1xuICAgICAgICAgIGQgPSB4ZDtcbiAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgbGVuID0geWQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGQgPSB5ZDtcbiAgICAgICAgICBlID0geGU7XG4gICAgICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xuICAgICAgICBpZiAoayA+IGkpIHtcbiAgICAgICAgICBrID0gaTtcbiAgICAgICAgICBkLmxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZC5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAoaSA9IGs7IGktLTsgKVxuICAgICAgICAgIGQucHVzaCgwKTtcbiAgICAgICAgZC5yZXZlcnNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0geGQubGVuZ3RoO1xuICAgICAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgICAgIHhMVHkgPSBpIDwgbGVuO1xuICAgICAgICBpZiAoeExUeSlcbiAgICAgICAgICBsZW4gPSBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoeGRbaV0gIT0geWRbaV0pIHtcbiAgICAgICAgICAgIHhMVHkgPSB4ZFtpXSA8IHlkW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHhMVHkpIHtcbiAgICAgICAgZCA9IHhkO1xuICAgICAgICB4ZCA9IHlkO1xuICAgICAgICB5ZCA9IGQ7XG4gICAgICAgIHkucyA9IC15LnM7XG4gICAgICB9XG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpXG4gICAgICAgIHhkW2xlbisrXSA9IDA7XG4gICAgICBmb3IgKGkgPSB5ZC5sZW5ndGg7IGkgPiBrOyApIHtcbiAgICAgICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xuICAgICAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDsgKVxuICAgICAgICAgICAgeGRbal0gPSBCQVNFIC0gMTtcbiAgICAgICAgICAtLXhkW2pdO1xuICAgICAgICAgIHhkW2ldICs9IEJBU0U7XG4gICAgICAgIH1cbiAgICAgICAgeGRbaV0gLT0geWRbaV07XG4gICAgICB9XG4gICAgICBmb3IgKDsgeGRbLS1sZW5dID09PSAwOyApXG4gICAgICAgIHhkLnBvcCgpO1xuICAgICAgZm9yICg7IHhkWzBdID09PSAwOyB4ZC5zaGlmdCgpKVxuICAgICAgICAtLWU7XG4gICAgICBpZiAoIXhkWzBdKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xuICAgICAgeS5kID0geGQ7XG4gICAgICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gICAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgICB9O1xuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgcSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgeSA9IG5ldyBDdG9yKHkpO1xuICAgICAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgICBpZiAoIXkuZCB8fCB4LmQgJiYgIXguZFswXSkge1xuICAgICAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbiAgICAgIH1cbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xuICAgICAgICBxID0gZGl2aWRlKHgsIHkuYWJzKCksIDAsIDMsIDEpO1xuICAgICAgICBxLnMgKj0geS5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IGRpdmlkZSh4LCB5LCAwLCBDdG9yLm1vZHVsbywgMSk7XG4gICAgICB9XG4gICAgICBxID0gcS50aW1lcyh5KTtcbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgIHJldHVybiB4Lm1pbnVzKHEpO1xuICAgIH07XG4gICAgUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5hdHVyYWxFeHBvbmVudGlhbCh0aGlzKTtcbiAgICB9O1xuICAgIFAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xuICAgIH07XG4gICAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICB4LnMgPSAteC5zO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHgpO1xuICAgIH07XG4gICAgUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICAgIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucylcbiAgICAgICAgICB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICAgICAgZWxzZSBpZiAoIXguZClcbiAgICAgICAgICB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgICAgaWYgKHgucyAhPSB5LnMpIHtcbiAgICAgICAgeS5zID0gLXkucztcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XG4gICAgICB9XG4gICAgICB4ZCA9IHguZDtcbiAgICAgIHlkID0geS5kO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgICAgIGlmICgheWRbMF0pXG4gICAgICAgICAgeSA9IG5ldyBDdG9yKHgpO1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgICAgIH1cbiAgICAgIGsgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xuICAgICAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gICAgICB4ZCA9IHhkLnNsaWNlKCk7XG4gICAgICBpID0gayAtIGU7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICBkID0geGQ7XG4gICAgICAgICAgaSA9IC1pO1xuICAgICAgICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkID0geWQ7XG4gICAgICAgICAgZSA9IGs7XG4gICAgICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XG4gICAgICAgIGxlbiA9IGsgPiBsZW4gPyBrICsgMSA6IGxlbiArIDE7XG4gICAgICAgIGlmIChpID4gbGVuKSB7XG4gICAgICAgICAgaSA9IGxlbjtcbiAgICAgICAgICBkLmxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZC5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAoOyBpLS07IClcbiAgICAgICAgICBkLnB1c2goMCk7XG4gICAgICAgIGQucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgICAgaSA9IHlkLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gLSBpIDwgMCkge1xuICAgICAgICBpID0gbGVuO1xuICAgICAgICBkID0geWQ7XG4gICAgICAgIHlkID0geGQ7XG4gICAgICAgIHhkID0gZDtcbiAgICAgIH1cbiAgICAgIGZvciAoY2FycnkgPSAwOyBpOyApIHtcbiAgICAgICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcbiAgICAgICAgeGRbaV0gJT0gQkFTRTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB4ZC51bnNoaWZ0KGNhcnJ5KTtcbiAgICAgICAgKytlO1xuICAgICAgfVxuICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7IHhkWy0tbGVuXSA9PSAwOyApXG4gICAgICAgIHhkLnBvcCgpO1xuICAgICAgeS5kID0geGQ7XG4gICAgICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gICAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgICB9O1xuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIHZhciBrLCB4ID0gdGhpcztcbiAgICAgIGlmICh6ICE9PSB2b2lkIDAgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMClcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgeik7XG4gICAgICBpZiAoeC5kKSB7XG4gICAgICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcbiAgICAgICAgaWYgKHogJiYgeC5lICsgMSA+IGspXG4gICAgICAgICAgayA9IHguZSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gTmFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfTtcbiAgICBQLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCB4LmUgKyAxLCBDdG9yLnJvdW5kaW5nKTtcbiAgICB9O1xuICAgIFAuc2luZSA9IFAuc2luID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgICBpZiAoeC5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID4gMiA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xuICAgIH07XG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbSwgbiwgc2QsIHIsIHJlcCwgdCwgeCA9IHRoaXMsIGQgPSB4LmQsIGUgPSB4LmUsIHMgPSB4LnMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKHMgIT09IDEgfHwgIWQgfHwgIWRbMF0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xuICAgICAgfVxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3gpO1xuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XG4gICAgICAgIG4gPSBkaWdpdHNUb1N0cmluZyhkKTtcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKVxuICAgICAgICAgIG4gKz0gXCIwXCI7XG4gICAgICAgIHMgPSBNYXRoLnNxcnQobik7XG4gICAgICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcbiAgICAgICAgICBuID0gXCI1ZVwiICsgZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKFwiZVwiKSArIDEpICsgZTtcbiAgICAgICAgfVxuICAgICAgICByID0gbmV3IEN0b3Iobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHQgPSByO1xuICAgICAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xuICAgICAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xuICAgICAgICAgIGlmIChuID09IFwiOTk5OVwiIHx8ICFyZXAgJiYgbiA9PSBcIjQ5OTlcIikge1xuICAgICAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xuICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xuICAgICAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZCArPSA0O1xuICAgICAgICAgICAgcmVwID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gXCI1XCIpIHtcbiAgICAgICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xuICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcbiAgICB9O1xuICAgIFAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgICBpZiAoeC5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyAxMDtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSAxO1xuICAgICAgeCA9IHguc2luKCk7XG4gICAgICB4LnMgPSAxO1xuICAgICAgeCA9IGRpdmlkZSh4LCBuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCksIHByICsgMTAsIDApO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgICAgIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDQgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbiAgICB9O1xuICAgIFAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBjYXJyeSwgZSwgaSwgaywgciwgckwsIHQsIHhkTCwgeWRMLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHhkID0geC5kLCB5ZCA9ICh5ID0gbmV3IEN0b3IoeSkpLmQ7XG4gICAgICB5LnMgKj0geC5zO1xuICAgICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xuICAgICAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGQgPyBOYU4gOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xuICAgICAgfVxuICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICAgICAgeGRMID0geGQubGVuZ3RoO1xuICAgICAgeWRMID0geWQubGVuZ3RoO1xuICAgICAgaWYgKHhkTCA8IHlkTCkge1xuICAgICAgICByID0geGQ7XG4gICAgICAgIHhkID0geWQ7XG4gICAgICAgIHlkID0gcjtcbiAgICAgICAgckwgPSB4ZEw7XG4gICAgICAgIHhkTCA9IHlkTDtcbiAgICAgICAgeWRMID0gckw7XG4gICAgICB9XG4gICAgICByID0gW107XG4gICAgICByTCA9IHhkTCArIHlkTDtcbiAgICAgIGZvciAoaSA9IHJMOyBpLS07IClcbiAgICAgICAgci5wdXNoKDApO1xuICAgICAgZm9yIChpID0geWRMOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yIChrID0geGRMICsgaTsgayA+IGk7ICkge1xuICAgICAgICAgIHQgPSByW2tdICsgeWRbaV0gKiB4ZFtrIC0gaSAtIDFdICsgY2Fycnk7XG4gICAgICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xuICAgICAgICAgIGNhcnJ5ID0gdCAvIEJBU0UgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xuICAgICAgfVxuICAgICAgZm9yICg7ICFyWy0tckxdOyApXG4gICAgICAgIHIucG9wKCk7XG4gICAgICBpZiAoY2FycnkpXG4gICAgICAgICsrZTtcbiAgICAgIGVsc2VcbiAgICAgICAgci5zaGlmdCgpO1xuICAgICAgeS5kID0gcjtcbiAgICAgIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xuICAgICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpIDogeTtcbiAgICB9O1xuICAgIFAudG9CaW5hcnkgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xuICAgIH07XG4gICAgUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgICAgIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICB4ID0gbmV3IEN0b3IoeCk7XG4gICAgICBpZiAoZHAgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICBlbHNlXG4gICAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHgsIGRwICsgeC5lICsgMSwgcm0pO1xuICAgIH07XG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gICAgICB2YXIgc3RyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoZHAgPT09IHZvaWQgMCkge1xuICAgICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICAgICAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICAgICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcbiAgICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSwgZHAgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbiAgICB9O1xuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICAgICAgdmFyIHN0ciwgeSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGRwID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICAgICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XG4gICAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xuICAgIH07XG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24obWF4RCkge1xuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGssIG4sIG4wLCBuMSwgcHIsIHEsIHIsIHggPSB0aGlzLCB4ZCA9IHguZCwgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXhkKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gICAgICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XG4gICAgICBkMSA9IG4wID0gbmV3IEN0b3IoMCk7XG4gICAgICBkID0gbmV3IEN0b3IoZDEpO1xuICAgICAgZSA9IGQuZSA9IGdldFByZWNpc2lvbih4ZCkgLSB4LmUgLSAxO1xuICAgICAgayA9IGUgJSBMT0dfQkFTRTtcbiAgICAgIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XG4gICAgICBpZiAobWF4RCA9PSBudWxsKSB7XG4gICAgICAgIG1heEQgPSBlID4gMCA/IGQgOiBuMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuZXcgQ3RvcihtYXhEKTtcbiAgICAgICAgaWYgKCFuLmlzSW50KCkgfHwgbi5sdChuMSkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XG4gICAgICAgIG1heEQgPSBuLmd0KGQpID8gZSA+IDAgPyBkIDogbjEgOiBuO1xuICAgICAgfVxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgIG4gPSBuZXcgQ3RvcihkaWdpdHNUb1N0cmluZyh4ZCkpO1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBxID0gZGl2aWRlKG4sIGQsIDAsIDEsIDEpO1xuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xuICAgICAgICBpZiAoZDIuY21wKG1heEQpID09IDEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGQwID0gZDE7XG4gICAgICAgIGQxID0gZDI7XG4gICAgICAgIGQyID0gbjE7XG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XG4gICAgICAgIG4wID0gZDI7XG4gICAgICAgIGQyID0gZDtcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xuICAgICAgICBuID0gZDI7XG4gICAgICB9XG4gICAgICBkMiA9IGRpdmlkZShtYXhELm1pbnVzKGQwKSwgZDEsIDAsIDEsIDEpO1xuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xuICAgICAgciA9IGRpdmlkZShuMSwgZDEsIGUsIDEpLm1pbnVzKHgpLmFicygpLmNtcChkaXZpZGUobjAsIGQwLCBlLCAxKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIFAudG9IZXhhZGVjaW1hbCA9IFAudG9IZXggPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcbiAgICB9O1xuICAgIFAudG9OZWFyZXN0ID0gZnVuY3Rpb24oeSwgcm0pIHtcbiAgICAgIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gICAgICB4ID0gbmV3IEN0b3IoeCk7XG4gICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgIGlmICgheC5kKVxuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICAgICAgaWYgKHJtID09PSB2b2lkIDApIHtcbiAgICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF4LmQpXG4gICAgICAgICAgcmV0dXJuIHkucyA/IHggOiB5O1xuICAgICAgICBpZiAoIXkuZCkge1xuICAgICAgICAgIGlmICh5LnMpXG4gICAgICAgICAgICB5LnMgPSB4LnM7XG4gICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh5LmRbMF0pIHtcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgZmluYWxpc2UoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LnMgPSB4LnM7XG4gICAgICAgIHggPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gK3RoaXM7XG4gICAgfTtcbiAgICBQLnRvT2N0YWwgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xuICAgIH07XG4gICAgUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgZSwgaywgcHIsIHIsIHJtLCBzLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHluID0gKyh5ID0gbmV3IEN0b3IoeSkpO1xuICAgICAgaWYgKCF4LmQgfHwgIXkuZCB8fCAheC5kWzBdIHx8ICF5LmRbMF0pXG4gICAgICAgIHJldHVybiBuZXcgQ3RvcihtYXRocG93KCt4LCB5bikpO1xuICAgICAgeCA9IG5ldyBDdG9yKHgpO1xuICAgICAgaWYgKHguZXEoMSkpXG4gICAgICAgIHJldHVybiB4O1xuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgIGlmICh5LmVxKDEpKVxuICAgICAgICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcbiAgICAgIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICAgICAgaWYgKGUgPj0geS5kLmxlbmd0aCAtIDEgJiYgKGsgPSB5biA8IDAgPyAteW4gOiB5bikgPD0gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcbiAgICAgICAgcmV0dXJuIHkucyA8IDAgPyBuZXcgQ3RvcigxKS5kaXYocikgOiBmaW5hbGlzZShyLCBwciwgcm0pO1xuICAgICAgfVxuICAgICAgcyA9IHgucztcbiAgICAgIGlmIChzIDwgMCkge1xuICAgICAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKVxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgICAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApXG4gICAgICAgICAgcyA9IDE7XG4gICAgICAgIGlmICh4LmUgPT0gMCAmJiB4LmRbMF0gPT0gMSAmJiB4LmQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB4LnMgPSBzO1xuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrID0gbWF0aHBvdygreCwgeW4pO1xuICAgICAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaykgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coXCIwLlwiICsgZGlnaXRzVG9TdHJpbmcoeC5kKSkgLyBNYXRoLkxOMTAgKyB4LmUgKyAxKSkgOiBuZXcgQ3RvcihrICsgXCJcIikuZTtcbiAgICAgIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSlcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGUgPiAwID8gcyAvIDAgOiAwKTtcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICBDdG9yLnJvdW5kaW5nID0geC5zID0gMTtcbiAgICAgIGsgPSBNYXRoLm1pbigxMiwgKGUgKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgciA9IG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgcHIgKyBrKSksIHByKTtcbiAgICAgIGlmIChyLmQpIHtcbiAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgNSwgMSk7XG4gICAgICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgcHIsIHJtKSkge1xuICAgICAgICAgIGUgPSBwciArIDEwO1xuICAgICAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XG4gICAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKHByICsgMSwgcHIgKyAxNSkgKyAxID09IDFlMTQpIHtcbiAgICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgci5zID0gcztcbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgICAgIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xuICAgIH07XG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICAgICAgdmFyIHN0ciwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKHNkID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgICAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XG4gICAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xuICAgIH07XG4gICAgUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gICAgICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKHNkID09PSB2b2lkIDApIHtcbiAgICAgICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xuICAgIH07XG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICAgICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xuICAgIH07XG4gICAgUC50cnVuY2F0ZWQgPSBQLnRydW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDEpO1xuICAgIH07XG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcbiAgICAgIHJldHVybiB4LmlzTmVnKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRpZ2l0c1RvU3RyaW5nKGQpIHtcbiAgICAgIHZhciBpLCBrLCB3cywgaW5kZXhPZkxhc3RXb3JkID0gZC5sZW5ndGggLSAxLCBzdHIgPSBcIlwiLCB3ID0gZFswXTtcbiAgICAgIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XG4gICAgICAgIHN0ciArPSB3O1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXhPZkxhc3RXb3JkOyBpKyspIHtcbiAgICAgICAgICB3cyA9IGRbaV0gKyBcIlwiO1xuICAgICAgICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaylcbiAgICAgICAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgICAgIHN0ciArPSB3cztcbiAgICAgICAgfVxuICAgICAgICB3ID0gZFtpXTtcbiAgICAgICAgd3MgPSB3ICsgXCJcIjtcbiAgICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgICAgICBpZiAoaylcbiAgICAgICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgICAgIH0gZWxzZSBpZiAodyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICB9XG4gICAgICBmb3IgKDsgdyAlIDEwID09PSAwOyApXG4gICAgICAgIHcgLz0gMTA7XG4gICAgICByZXR1cm4gc3RyICsgdztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4yLCBtYXgyKSB7XG4gICAgICBpZiAoaSAhPT0gfn5pIHx8IGkgPCBtaW4yIHx8IGkgPiBtYXgyKSB7XG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1JvdW5kaW5nRGlnaXRzKGQsIGksIHJtLCByZXBlYXRpbmcpIHtcbiAgICAgIHZhciBkaSwgaywgciwgcmQ7XG4gICAgICBmb3IgKGsgPSBkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICAtLWk7XG4gICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICBpICs9IExPR19CQVNFO1xuICAgICAgICBkaSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgfVxuICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gICAgICByZCA9IGRbZGldICUgayB8IDA7XG4gICAgICBpZiAocmVwZWF0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgIHJkID0gcmQgLyAxMDAgfCAwO1xuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgICAgIHJkID0gcmQgLyAxMCB8IDA7XG4gICAgICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNWU0IHx8IHJkID09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciA9IChybSA8IDQgJiYgcmQgKyAxID09IGsgfHwgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMikgLSAxIHx8IChyZCA9PSBrIC8gMiB8fCByZCA9PSAwKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpIDwgNCkge1xuICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICByZCA9IHJkIC8gMWUzIHwgMDtcbiAgICAgICAgICBlbHNlIGlmIChpID09IDEpXG4gICAgICAgICAgICByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgICAgICBlbHNlIGlmIChpID09IDIpXG4gICAgICAgICAgICByZCA9IHJkIC8gMTAgfCAwO1xuICAgICAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIgPSAoKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkICsgMSA9PSBrIHx8ICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiYgKGRbZGkgKyAxXSAvIGsgLyAxZTMgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMykgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcbiAgICAgIHZhciBqLCBhcnIgPSBbMF0sIGFyckwsIGkgPSAwLCBzdHJMID0gc3RyLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgc3RyTDsgKSB7XG4gICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgKVxuICAgICAgICAgIGFyclthcnJMXSAqPSBiYXNlSW47XG4gICAgICAgIGFyclswXSArPSBOVU1FUkFMUy5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIGFycltqICsgMV0gPSAwO1xuICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcbiAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XG4gICAgICB2YXIgaywgeSwgbGVuID0geC5kLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCAzMikge1xuICAgICAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xuICAgICAgICB5ID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9IDE2O1xuICAgICAgICB5ID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gICAgICB9XG4gICAgICBDdG9yLnByZWNpc2lvbiArPSBrO1xuICAgICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKHkpLCBuZXcgQ3RvcigxKSk7XG4gICAgICBmb3IgKHZhciBpID0gazsgaS0tOyApIHtcbiAgICAgICAgdmFyIGNvczJ4ID0geC50aW1lcyh4KTtcbiAgICAgICAgeCA9IGNvczJ4LnRpbWVzKGNvczJ4KS5taW51cyhjb3MyeCkudGltZXMoOCkucGx1cygxKTtcbiAgICAgIH1cbiAgICAgIEN0b3IucHJlY2lzaW9uIC09IGs7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgdmFyIGRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gbXVsdGlwbHlJbnRlZ2VyKHgsIGssIGJhc2UpIHtcbiAgICAgICAgdmFyIHRlbXAsIGNhcnJ5ID0gMCwgaSA9IHgubGVuZ3RoO1xuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTsgKSB7XG4gICAgICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcbiAgICAgICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkpXG4gICAgICAgICAgeC51bnNoaWZ0KGNhcnJ5KTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xuICAgICAgICB2YXIgaSwgcjtcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XG4gICAgICAgICAgciA9IGFMID4gYkwgPyAxIDogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gciA9IDA7IGkgPCBhTDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XG4gICAgICAgICAgICAgIHIgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKDsgYUwtLTsgKSB7XG4gICAgICAgICAgYVthTF0gLT0gaTtcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IClcbiAgICAgICAgICBhLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xuICAgICAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLCB5TCwgeXosIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzaWduMiA9IHgucyA9PSB5LnMgPyAxIDogLTEsIHhkID0geC5kLCB5ZCA9IHkuZDtcbiAgICAgICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcigheC5zIHx8ICF5LnMgfHwgKHhkID8geWQgJiYgeGRbMF0gPT0geWRbMF0gOiAheWQpID8gTmFOIDogeGQgJiYgeGRbMF0gPT0gMCB8fCAheWQgPyBzaWduMiAqIDAgOiBzaWduMiAvIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgbG9nQmFzZSA9IDE7XG4gICAgICAgICAgZSA9IHguZSAtIHkuZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlID0gQkFTRTtcbiAgICAgICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XG4gICAgICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XG4gICAgICAgIHEgPSBuZXcgQ3RvcihzaWduMik7XG4gICAgICAgIHFkID0gcS5kID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IHlkW2ldID09ICh4ZFtpXSB8fCAwKTsgaSsrKVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKVxuICAgICAgICAgIGUtLTtcbiAgICAgICAgaWYgKHByID09IG51bGwpIHtcbiAgICAgICAgICBzZCA9IHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKGRwKSB7XG4gICAgICAgICAgc2QgPSBwciArICh4LmUgLSB5LmUpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZCA9IHByO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZCA8IDApIHtcbiAgICAgICAgICBxZC5wdXNoKDEpO1xuICAgICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgaWYgKHlMID09IDEpIHtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgeWQgPSB5ZFswXTtcbiAgICAgICAgICAgIHNkKys7XG4gICAgICAgICAgICBmb3IgKDsgKGkgPCB4TCB8fCBrKSAmJiBzZC0tOyBpKyspIHtcbiAgICAgICAgICAgICAgdCA9IGsgKiBiYXNlICsgKHhkW2ldIHx8IDApO1xuICAgICAgICAgICAgICBxZFtpXSA9IHQgLyB5ZCB8IDA7XG4gICAgICAgICAgICAgIGsgPSB0ICUgeWQgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrID0gYmFzZSAvICh5ZFswXSArIDEpIHwgMDtcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICB5ZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgICAgIHhkID0gbXVsdGlwbHlJbnRlZ2VyKHhkLCBrLCBiYXNlKTtcbiAgICAgICAgICAgICAgeUwgPSB5ZC5sZW5ndGg7XG4gICAgICAgICAgICAgIHhMID0geGQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGkgPSB5TDtcbiAgICAgICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgKVxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IDA7XG4gICAgICAgICAgICB5eiA9IHlkLnNsaWNlKCk7XG4gICAgICAgICAgICB5ei51bnNoaWZ0KDApO1xuICAgICAgICAgICAgeWQwID0geWRbMF07XG4gICAgICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpXG4gICAgICAgICAgICAgICsreWQwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcbiAgICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTClcbiAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XG4gICAgICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGsgPj0gYmFzZSlcbiAgICAgICAgICAgICAgICAgICAgayA9IGJhc2UgLSAxO1xuICAgICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWQsIHByb2RMLCBiYXNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGsgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY21wID0gayA9IDE7XG4gICAgICAgICAgICAgICAgICBwcm9kID0geWQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKVxuICAgICAgICAgICAgICAgICAgcHJvZC51bnNoaWZ0KDApO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHlkLCByZW1MLCBiYXNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIHJlbSA9IFswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxZFtpKytdID0gaztcbiAgICAgICAgICAgICAgaWYgKGNtcCAmJiByZW1bMF0pIHtcbiAgICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbSA9IFt4ZFt4aV1dO1xuICAgICAgICAgICAgICAgIHJlbUwgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPT0gdm9pZCAwKSAmJiBzZC0tKTtcbiAgICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFxZFswXSlcbiAgICAgICAgICAgIHFkLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ0Jhc2UgPT0gMSkge1xuICAgICAgICAgIHEuZSA9IGU7XG4gICAgICAgICAgaW5leGFjdCA9IG1vcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XG4gICAgICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xuICAgICAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgb3V0OlxuICAgICAgICBpZiAoc2QgIT0gbnVsbCkge1xuICAgICAgICAgIHhkID0geC5kO1xuICAgICAgICAgIGlmICgheGQpXG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICAgIGkgPSBzZCAtIGRpZ2l0cztcbiAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgICAgICAgICBqID0gc2Q7XG4gICAgICAgICAgICB3ID0geGRbeGRpID0gMF07XG4gICAgICAgICAgICByZCA9IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgICAgICAgICAgayA9IHhkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh4ZGkgPj0gaykge1xuICAgICAgICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTsgKVxuICAgICAgICAgICAgICAgICAgeGQucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB3ID0gcmQgPSAwO1xuICAgICAgICAgICAgICAgIGRpZ2l0cyA9IDE7XG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHcgPSBrID0geGRbeGRpXTtcbiAgICAgICAgICAgICAgZm9yIChkaWdpdHMgPSAxOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8IHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xuICAgICAgICAgIHJvdW5kVXAgPSBybSA8IDQgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKSA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IGlzVHJ1bmNhdGVkIHx8IHJtID09IDYgJiYgKGkgPiAwID8gaiA+IDAgPyB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgOiAwIDogeGRbeGRpIC0gMV0pICUgMTAgJiAxIHx8IHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xuICAgICAgICAgICAgeGQubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XG4gICAgICAgICAgICAgIHhkWzBdID0gbWF0aHBvdygxMCwgKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRSk7XG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeGRbMF0gPSB4LmUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIHhkLmxlbmd0aCA9IHhkaTtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICAgICAgeGRpLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhkLmxlbmd0aCA9IHhkaSArIDE7XG4gICAgICAgICAgICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcbiAgICAgICAgICAgIHhkW3hkaV0gPSBqID4gMCA/ICh3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgJSBtYXRocG93KDEwLCBqKSB8IDApICogayA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICAgICAgaWYgKHhkaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhkWzBdOyBqID49IDEwOyBqIC89IDEwKVxuICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGogPSB4ZFswXSArPSBrO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApXG4gICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xuICAgICAgICAgICAgICAgICAgeC5lKys7XG4gICAgICAgICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSlcbiAgICAgICAgICAgICAgICAgICAgeGRbMF0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ZFt4ZGldICs9IGs7XG4gICAgICAgICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHhkW3hkaS0tXSA9IDA7XG4gICAgICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0geGQubGVuZ3RoOyB4ZFstLWldID09PSAwOyApXG4gICAgICAgICAgICB4ZC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgIGlmICh4LmUgPiBDdG9yLm1heEUpIHtcbiAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICAgIHguZSA9IE5hTjtcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBDdG9yLm1pbkUpIHtcbiAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbml0ZVRvU3RyaW5nKHgsIGlzRXhwLCBzZCkge1xuICAgICAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgICAgIHJldHVybiBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgICAgIHZhciBrLCBlID0geC5lLCBzdHIgPSBkaWdpdHNUb1N0cmluZyh4LmQpLCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgaWYgKGlzRXhwKSB7XG4gICAgICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcbiAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSkgKyBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyBcImVcIiA6IFwiZStcIikgKyB4LmU7XG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgICAgIHN0ciA9IFwiMC5cIiArIGdldFplcm9TdHJpbmcoLWUgLSAxKSArIHN0cjtcbiAgICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMClcbiAgICAgICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgICAgIH0gZWxzZSBpZiAoZSA+PSBsZW4pIHtcbiAgICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xuICAgICAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGUgLSAxKSA+IDApXG4gICAgICAgICAgc3RyID0gc3RyICsgXCIuXCIgKyBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChrID0gZSArIDEpIDwgbGVuKVxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBrKSArIFwiLlwiICsgc3RyLnNsaWNlKGspO1xuICAgICAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XG4gICAgICAgICAgaWYgKGUgKyAxID09PSBsZW4pXG4gICAgICAgICAgICBzdHIgKz0gXCIuXCI7XG4gICAgICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJhc2UxMEV4cG9uZW50KGRpZ2l0cywgZSkge1xuICAgICAgdmFyIHcgPSBkaWdpdHNbMF07XG4gICAgICBmb3IgKGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApXG4gICAgICAgIGUrKztcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xuICAgICAgaWYgKHNkID4gTE4xMF9QUkVDSVNJT04pIHtcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICBpZiAocHIpXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoTE4xMCksIHNkLCAxLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XG4gICAgICBpZiAoc2QgPiBQSV9QUkVDSVNJT04pXG4gICAgICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xuICAgICAgdmFyIHcgPSBkaWdpdHMubGVuZ3RoIC0gMSwgbGVuID0gdyAqIExPR19CQVNFICsgMTtcbiAgICAgIHcgPSBkaWdpdHNbd107XG4gICAgICBpZiAodykge1xuICAgICAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIGZvciAodyA9IGRpZ2l0c1swXTsgdyA+PSAxMDsgdyAvPSAxMClcbiAgICAgICAgICBsZW4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xuICAgICAgdmFyIHpzID0gXCJcIjtcbiAgICAgIGZvciAoOyBrLS07IClcbiAgICAgICAgenMgKz0gXCIwXCI7XG4gICAgICByZXR1cm4genM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludFBvdyhDdG9yLCB4LCBuLCBwcikge1xuICAgICAgdmFyIGlzVHJ1bmNhdGVkLCByID0gbmV3IEN0b3IoMSksIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSArIDQpO1xuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByID0gci50aW1lcyh4KTtcbiAgICAgICAgICBpZiAodHJ1bmNhdGUoci5kLCBrKSlcbiAgICAgICAgICAgIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBuID0gci5kLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMClcbiAgICAgICAgICAgICsrci5kW25dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xuICAgICAgICB0cnVuY2F0ZSh4LmQsIGspO1xuICAgICAgfVxuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzT2RkKG4pIHtcbiAgICAgIHJldHVybiBuLmRbbi5kLmxlbmd0aCAtIDFdICYgMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oQ3RvciwgYXJncywgbHRndCkge1xuICAgICAgdmFyIHksIHggPSBuZXcgQ3RvcihhcmdzWzBdKSwgaSA9IDA7XG4gICAgICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7ICkge1xuICAgICAgICB5ID0gbmV3IEN0b3IoYXJnc1tpXSk7XG4gICAgICAgIGlmICgheS5zKSB7XG4gICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoeFtsdGd0XSh5KSkge1xuICAgICAgICAgIHggPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XG4gICAgICB2YXIgZGVub21pbmF0b3IsIGd1YXJkLCBqLCBwb3cyLCBzdW0sIHQsIHdwciwgcmVwID0gMCwgaSA9IDAsIGsgPSAwLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgaWYgKCF4LmQgfHwgIXguZFswXSB8fCB4LmUgPiAxNykge1xuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeC5kID8gIXguZFswXSA/IDEgOiB4LnMgPCAwID8gMCA6IDEgLyAwIDogeC5zID8geC5zIDwgMCA/IDAgOiB4IDogMCAvIDApO1xuICAgICAgfVxuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgd3ByID0gcHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cHIgPSBzZDtcbiAgICAgIH1cbiAgICAgIHQgPSBuZXcgQ3RvcigwLjAzMTI1KTtcbiAgICAgIHdoaWxlICh4LmUgPiAtMikge1xuICAgICAgICB4ID0geC50aW1lcyh0KTtcbiAgICAgICAgayArPSA1O1xuICAgICAgfVxuICAgICAgZ3VhcmQgPSBNYXRoLmxvZyhtYXRocG93KDIsIGspKSAvIE1hdGguTE4xMCAqIDIgKyA1IHwgMDtcbiAgICAgIHdwciArPSBndWFyZDtcbiAgICAgIGRlbm9taW5hdG9yID0gcG93MiA9IHN1bSA9IG5ldyBDdG9yKDEpO1xuICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgcG93MiA9IGZpbmFsaXNlKHBvdzIudGltZXMoeCksIHdwciwgMSk7XG4gICAgICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcbiAgICAgICAgdCA9IHN1bS5wbHVzKGRpdmlkZShwb3cyLCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XG4gICAgICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICAgICAgaiA9IGs7XG4gICAgICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgICAgIHN1bSA9IGZpbmFsaXNlKHN1bS50aW1lcyhzdW0pLCB3cHIsIDEpO1xuICAgICAgICAgIGlmIChzZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bS5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XG4gICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcG93MiA9IHQgPSBuZXcgQ3RvcigxKTtcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgIHJlcCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdW0gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuYXR1cmFsTG9nYXJpdGhtKHksIHNkKSB7XG4gICAgICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtLCB0LCB3cHIsIHgxLCB4MiwgbiA9IDEsIGd1YXJkID0gMTAsIHggPSB5LCB4ZCA9IHguZCwgQ3RvciA9IHguY29uc3RydWN0b3IsIHJtID0gQ3Rvci5yb3VuZGluZywgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3Rvcih4ZCAmJiAheGRbMF0gPyAtMSAvIDAgOiB4LnMgIT0gMSA/IE5hTiA6IHhkID8gMCA6IHgpO1xuICAgICAgfVxuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgd3ByID0gcHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cHIgPSBzZDtcbiAgICAgIH1cbiAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcbiAgICAgIGMwID0gYy5jaGFyQXQoMCk7XG4gICAgICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxNWUxNCkge1xuICAgICAgICB3aGlsZSAoYzAgPCA3ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDMpIHtcbiAgICAgICAgICB4ID0geC50aW1lcyh5KTtcbiAgICAgICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICAgICAgICBjMCA9IGMuY2hhckF0KDApO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgICBlID0geC5lO1xuICAgICAgICBpZiAoYzAgPiAxKSB7XG4gICAgICAgICAgeCA9IG5ldyBDdG9yKFwiMC5cIiArIGMpO1xuICAgICAgICAgIGUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gbmV3IEN0b3IoYzAgKyBcIi5cIiArIGMuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArIFwiXCIpO1xuICAgICAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArIFwiLlwiICsgYy5zbGljZSgxKSksIHdwciAtIGd1YXJkKS5wbHVzKHQpO1xuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgICByZXR1cm4gc2QgPT0gbnVsbCA/IGZpbmFsaXNlKHgsIHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKSA6IHg7XG4gICAgICB9XG4gICAgICB4MSA9IHg7XG4gICAgICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcbiAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcbiAgICAgIGRlbm9taW5hdG9yID0gMztcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xuICAgICAgICB0ID0gc3VtLnBsdXMoZGl2aWRlKG51bWVyYXRvciwgbmV3IEN0b3IoZGVub21pbmF0b3IpLCB3cHIsIDEpKTtcbiAgICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcbiAgICAgICAgICBzdW0gPSBzdW0udGltZXMoMik7XG4gICAgICAgICAgaWYgKGUgIT09IDApXG4gICAgICAgICAgICBzdW0gPSBzdW0ucGx1cyhnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgXCJcIikpO1xuICAgICAgICAgIHN1bSA9IGRpdmlkZShzdW0sIG5ldyBDdG9yKG4pLCB3cHIsIDEpO1xuICAgICAgICAgIGlmIChzZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0uZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XG4gICAgICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICAgICAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcbiAgICAgICAgICAgICAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xuICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHQ7XG4gICAgICAgIGRlbm9taW5hdG9yICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vbkZpbml0ZVRvU3RyaW5nKHgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRGVjaW1hbCh4LCBzdHIpIHtcbiAgICAgIHZhciBlLCBpLCBsZW47XG4gICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZihcIi5cIikpID4gLTEpXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xuICAgICAgICBpZiAoZSA8IDApXG4gICAgICAgICAgZSA9IGk7XG4gICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgICAgIGUgPSBzdHIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspXG4gICAgICAgIDtcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbilcbiAgICAgICAgO1xuICAgICAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XG4gICAgICBpZiAoc3RyKSB7XG4gICAgICAgIGxlbiAtPSBpO1xuICAgICAgICB4LmUgPSBlID0gZSAtIGkgLSAxO1xuICAgICAgICB4LmQgPSBbXTtcbiAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcbiAgICAgICAgaWYgKGUgPCAwKVxuICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICB4LmQucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKVxuICAgICAgICAgICAgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKGkpO1xuICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSAtPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGktLTsgKVxuICAgICAgICAgIHN0ciArPSBcIjBcIjtcbiAgICAgICAgeC5kLnB1c2goK3N0cik7XG4gICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgIGlmICh4LmUgPiB4LmNvbnN0cnVjdG9yLm1heEUpIHtcbiAgICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LmUgPSAwO1xuICAgICAgICB4LmQgPSBbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcbiAgICAgIHZhciBiYXNlLCBDdG9yLCBkaXZpc29yLCBpLCBpc0Zsb2F0LCBsZW4sIHAsIHhkLCB4ZTtcbiAgICAgIGlmIChzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiTmFOXCIpIHtcbiAgICAgICAgaWYgKCErc3RyKVxuICAgICAgICAgIHgucyA9IE5hTjtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0hleC50ZXN0KHN0cikpIHtcbiAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCaW5hcnkudGVzdChzdHIpKSB7XG4gICAgICAgIGJhc2UgPSAyO1xuICAgICAgfSBlbHNlIGlmIChpc09jdGFsLnRlc3Qoc3RyKSkge1xuICAgICAgICBiYXNlID0gODtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHN0cik7XG4gICAgICB9XG4gICAgICBpID0gc3RyLnNlYXJjaCgvcC9pKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBwID0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMiwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gICAgICB9XG4gICAgICBpID0gc3RyLmluZGV4T2YoXCIuXCIpO1xuICAgICAgaXNGbG9hdCA9IGkgPj0gMDtcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGlzRmxvYXQpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICBpID0gbGVuIC0gaTtcbiAgICAgICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xuICAgICAgfVxuICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIEJBU0UpO1xuICAgICAgeGUgPSB4ZC5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpXG4gICAgICAgIHhkLnBvcCgpO1xuICAgICAgaWYgKGkgPCAwKVxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoeC5zICogMCk7XG4gICAgICB4LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgeGUpO1xuICAgICAgeC5kID0geGQ7XG4gICAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgICAgaWYgKGlzRmxvYXQpXG4gICAgICAgIHggPSBkaXZpZGUoeCwgZGl2aXNvciwgbGVuICogNCk7XG4gICAgICBpZiAocClcbiAgICAgICAgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XG4gICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XG4gICAgICB2YXIgaywgbGVuID0geC5kLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCAzKVxuICAgICAgICByZXR1cm4gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICAgICAgayA9IDEuNCAqIE1hdGguc3FydChsZW4pO1xuICAgICAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gICAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gICAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICAgICAgdmFyIHNpbjJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gICAgICBmb3IgKDsgay0tOyApIHtcbiAgICAgICAgc2luMl94ID0geC50aW1lcyh4KTtcbiAgICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW4yX3gudGltZXMoZDE2LnRpbWVzKHNpbjJfeCkubWludXMoZDIwKSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YXlsb3JTZXJpZXMoQ3RvciwgbiwgeCwgeSwgaXNIeXBlcmJvbGljKSB7XG4gICAgICB2YXIgaiwgdCwgdSwgeDIsIGkgPSAxLCBwciA9IEN0b3IucHJlY2lzaW9uLCBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgIHgyID0geC50aW1lcyh4KTtcbiAgICAgIHUgPSBuZXcgQ3Rvcih5KTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICB0ID0gZGl2aWRlKHUudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgICAgIHUgPSBpc0h5cGVyYm9saWMgPyB5LnBsdXModCkgOiB5Lm1pbnVzKHQpO1xuICAgICAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgICAgIHQgPSB1LnBsdXMoeSk7XG4gICAgICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZvciAoaiA9IGs7IHQuZFtqXSA9PT0gdS5kW2pdICYmIGotLTsgKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIGlmIChqID09IC0xKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IHU7XG4gICAgICAgIHUgPSB5O1xuICAgICAgICB5ID0gdDtcbiAgICAgICAgdCA9IGo7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgIHQuZC5sZW5ndGggPSBrICsgMTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcbiAgICAgIHZhciBuID0gYjtcbiAgICAgIHdoaWxlICgtLWUpXG4gICAgICAgIG4gKj0gYjtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcbiAgICAgIHZhciB0LCBpc05lZyA9IHgucyA8IDAsIHBpID0gZ2V0UGkoQ3RvciwgQ3Rvci5wcmVjaXNpb24sIDEpLCBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xuICAgICAgeCA9IHguYWJzKCk7XG4gICAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgICAgICBxdWFkcmFudCA9IGlzTmVnID8gNCA6IDE7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgdCA9IHguZGl2VG9JbnQocGkpO1xuICAgICAgaWYgKHQuaXNaZXJvKCkpIHtcbiAgICAgICAgcXVhZHJhbnQgPSBpc05lZyA/IDMgOiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgubWludXModC50aW1lcyhwaSkpO1xuICAgICAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgICAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDIgOiAzIDogaXNOZWcgPyA0IDogMTtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBxdWFkcmFudCA9IGlzT2RkKHQpID8gaXNOZWcgPyAxIDogNCA6IGlzTmVnID8gMyA6IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nQmluYXJ5KHgsIGJhc2VPdXQsIHNkLCBybSkge1xuICAgICAgdmFyIGJhc2UsIGUsIGksIGssIGxlbiwgcm91bmRVcCwgc3RyLCB4ZCwgeSwgQ3RvciA9IHguY29uc3RydWN0b3IsIGlzRXhwID0gc2QgIT09IHZvaWQgMDtcbiAgICAgIGlmIChpc0V4cCkge1xuICAgICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICAgICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIXguaXNGaW5pdGUoKSkge1xuICAgICAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xuICAgICAgICBpID0gc3RyLmluZGV4T2YoXCIuXCIpO1xuICAgICAgICBpZiAoaXNFeHApIHtcbiAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xuICAgICAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmFzZU91dCA9PSA4KSB7XG4gICAgICAgICAgICBzZCA9IHNkICogMyAtIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2UgPSBiYXNlT3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgICAgICAgeSA9IG5ldyBDdG9yKDEpO1xuICAgICAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xuICAgICAgICAgIHkuZCA9IGNvbnZlcnRCYXNlKGZpbml0ZVRvU3RyaW5nKHkpLCAxMCwgYmFzZSk7XG4gICAgICAgICAgeS5lID0geS5kLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xuICAgICAgICBlID0gbGVuID0geGQubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7IClcbiAgICAgICAgICB4ZC5wb3AoKTtcbiAgICAgICAgaWYgKCF4ZFswXSkge1xuICAgICAgICAgIHN0ciA9IGlzRXhwID8gXCIwcCswXCIgOiBcIjBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGUtLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xuICAgICAgICAgICAgeC5kID0geGQ7XG4gICAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xuICAgICAgICAgICAgeGQgPSB4LmQ7XG4gICAgICAgICAgICBlID0geC5lO1xuICAgICAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSB4ZFtzZF07XG4gICAgICAgICAgayA9IGJhc2UgLyAyO1xuICAgICAgICAgIHJvdW5kVXAgPSByb3VuZFVwIHx8IHhkW3NkICsgMV0gIT09IHZvaWQgMDtcbiAgICAgICAgICByb3VuZFVwID0gcm0gPCA0ID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKSA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHwgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgICAgICB4ZC5sZW5ndGggPSBzZDtcbiAgICAgICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICAgICAgZm9yICg7ICsreGRbLS1zZF0gPiBiYXNlIC0gMTsgKSB7XG4gICAgICAgICAgICAgIHhkW3NkXSA9IDA7XG4gICAgICAgICAgICAgIGlmICghc2QpIHtcbiAgICAgICAgICAgICAgICArK2U7XG4gICAgICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbilcbiAgICAgICAgICAgIDtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSBcIlwiOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcbiAgICAgICAgICBpZiAoaXNFeHApIHtcbiAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChiYXNlT3V0ID09IDE2IHx8IGJhc2VPdXQgPT0gOCkge1xuICAgICAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XG4gICAgICAgICAgICAgICAgZm9yICgtLWxlbjsgbGVuICUgaTsgbGVuKyspXG4gICAgICAgICAgICAgICAgICBzdHIgKz0gXCIwXCI7XG4gICAgICAgICAgICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIGJhc2VPdXQpO1xuICAgICAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKVxuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIHN0ciA9IFwiMS5cIjsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgICAgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyAoZSA8IDAgPyBcInBcIiA6IFwicCtcIikgKyBlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIGZvciAoOyArK2U7IClcbiAgICAgICAgICAgICAgc3RyID0gXCIwXCIgKyBzdHI7XG4gICAgICAgICAgICBzdHIgPSBcIjAuXCIgKyBzdHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgrK2UgPiBsZW4pXG4gICAgICAgICAgICAgIGZvciAoZSAtPSBsZW47IGUtLTsgKVxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjBcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pXG4gICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArIFwiLlwiICsgc3RyLnNsaWNlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSAoYmFzZU91dCA9PSAxNiA/IFwiMHhcIiA6IGJhc2VPdXQgPT0gMiA/IFwiMGJcIiA6IGJhc2VPdXQgPT0gOCA/IFwiMG9cIiA6IFwiXCIpICsgc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgucyA8IDAgPyBcIi1cIiArIHN0ciA6IHN0cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoID4gbGVuKSB7XG4gICAgICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhYnMoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFicygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY29zKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5hY29zKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5hY29zaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGQoeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLnBsdXMoeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzaW4oeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW4oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNpbmgoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW5oKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0YW4oeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW4oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW5oKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcbiAgICAgIHkgPSBuZXcgdGhpcyh5KTtcbiAgICAgIHggPSBuZXcgdGhpcyh4KTtcbiAgICAgIHZhciByLCBwciA9IHRoaXMucHJlY2lzaW9uLCBybSA9IHRoaXMucm91bmRpbmcsIHdwciA9IHByICsgNDtcbiAgICAgIGlmICgheS5zIHx8ICF4LnMpIHtcbiAgICAgICAgciA9IG5ldyB0aGlzKE5hTik7XG4gICAgICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xuICAgICAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xuICAgICAgICByLnMgPSB5LnM7XG4gICAgICB9IGVsc2UgaWYgKCF4LmQgfHwgeS5pc1plcm8oKSkge1xuICAgICAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcbiAgICAgICAgci5zID0geS5zO1xuICAgICAgfSBlbHNlIGlmICgheS5kIHx8IHguaXNaZXJvKCkpIHtcbiAgICAgICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcbiAgICAgICAgci5zID0geS5zO1xuICAgICAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xuICAgICAgICB0aGlzLnJvdW5kaW5nID0gMTtcbiAgICAgICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XG4gICAgICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHByO1xuICAgICAgICB0aGlzLnJvdW5kaW5nID0gcm07XG4gICAgICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNicnQoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VpbCh4KSB7XG4gICAgICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uZmlnKG9iaikge1xuICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICB2YXIgaSwgcCwgdiwgdXNlRGVmYXVsdHMgPSBvYmouZGVmYXVsdHMgPT09IHRydWUsIHBzID0gW1xuICAgICAgICBcInByZWNpc2lvblwiLFxuICAgICAgICAxLFxuICAgICAgICBNQVhfRElHSVRTLFxuICAgICAgICBcInJvdW5kaW5nXCIsXG4gICAgICAgIDAsXG4gICAgICAgIDgsXG4gICAgICAgIFwidG9FeHBOZWdcIixcbiAgICAgICAgLUVYUF9MSU1JVCxcbiAgICAgICAgMCxcbiAgICAgICAgXCJ0b0V4cFBvc1wiLFxuICAgICAgICAwLFxuICAgICAgICBFWFBfTElNSVQsXG4gICAgICAgIFwibWF4RVwiLFxuICAgICAgICAwLFxuICAgICAgICBFWFBfTElNSVQsXG4gICAgICAgIFwibWluRVwiLFxuICAgICAgICAtRVhQX0xJTUlULFxuICAgICAgICAwLFxuICAgICAgICBcIm1vZHVsb1wiLFxuICAgICAgICAwLFxuICAgICAgICA5XG4gICAgICBdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGlmIChwID0gcHNbaV0sIHVzZURlZmF1bHRzKVxuICAgICAgICAgIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgICAgICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKG1hdGhmbG9vcih2KSA9PT0gdiAmJiB2ID49IHBzW2kgKyAxXSAmJiB2IDw9IHBzW2kgKyAyXSlcbiAgICAgICAgICAgIHRoaXNbcF0gPSB2O1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyBcIjogXCIgKyB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHAgPSBcImNyeXB0b1wiLCB1c2VEZWZhdWx0cylcbiAgICAgICAgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xuICAgICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSBcInVuZGVmaW5lZFwiICYmIGNyeXB0byAmJiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAgICAgICAgIHRoaXNbcF0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyBcIjogXCIgKyB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcyh4KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvc2goeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgICB2YXIgaSwgcCwgcHM7XG4gICAgICBmdW5jdGlvbiBEZWNpbWFsMih2KSB7XG4gICAgICAgIHZhciBlLCBpMiwgdCwgeCA9IHRoaXM7XG4gICAgICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsMikpXG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMih2KTtcbiAgICAgICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWwyO1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERlY2ltYWwyKSB7XG4gICAgICAgICAgeC5zID0gdi5zO1xuICAgICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgICAgaWYgKCF2LmQgfHwgdi5lID4gRGVjaW1hbDIubWF4RSkge1xuICAgICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IERlY2ltYWwyLm1pbkUpIHtcbiAgICAgICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICAgICAgICB4LmQgPSB2LmQuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICAgICAgeC5kID0gdi5kID8gdi5kLnNsaWNlKCkgOiB2LmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ID0gdHlwZW9mIHY7XG4gICAgICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgdiA9IC12O1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ID09PSB+fnYgJiYgdiA8IDFlNykge1xuICAgICAgICAgICAgZm9yIChlID0gMCwgaTIgPSB2OyBpMiA+PSAxMDsgaTIgLz0gMTApXG4gICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgICAgICBpZiAoZSA+IERlY2ltYWwyLm1heEUpIHtcbiAgICAgICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlIDwgRGVjaW1hbDIubWluRSkge1xuICAgICAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgICAgICB4LmQgPSBbdl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh2ICogMCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICB4LnMgPSBOYU47XG4gICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaTIgPSB2LmNoYXJDb2RlQXQoMCkpID09PSA0NSkge1xuICAgICAgICAgIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgICAgIHgucyA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpMiA9PT0gNDMpXG4gICAgICAgICAgICB2ID0gdi5zbGljZSgxKTtcbiAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0RlY2ltYWwudGVzdCh2KSA/IHBhcnNlRGVjaW1hbCh4LCB2KSA6IHBhcnNlT3RoZXIoeCwgdik7XG4gICAgICB9XG4gICAgICBEZWNpbWFsMi5wcm90b3R5cGUgPSBQO1xuICAgICAgRGVjaW1hbDIuUk9VTkRfVVAgPSAwO1xuICAgICAgRGVjaW1hbDIuUk9VTkRfRE9XTiA9IDE7XG4gICAgICBEZWNpbWFsMi5ST1VORF9DRUlMID0gMjtcbiAgICAgIERlY2ltYWwyLlJPVU5EX0ZMT09SID0gMztcbiAgICAgIERlY2ltYWwyLlJPVU5EX0hBTEZfVVAgPSA0O1xuICAgICAgRGVjaW1hbDIuUk9VTkRfSEFMRl9ET1dOID0gNTtcbiAgICAgIERlY2ltYWwyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XG4gICAgICBEZWNpbWFsMi5ST1VORF9IQUxGX0NFSUwgPSA3O1xuICAgICAgRGVjaW1hbDIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XG4gICAgICBEZWNpbWFsMi5FVUNMSUQgPSA5O1xuICAgICAgRGVjaW1hbDIuY29uZmlnID0gRGVjaW1hbDIuc2V0ID0gY29uZmlnO1xuICAgICAgRGVjaW1hbDIuY2xvbmUgPSBjbG9uZTtcbiAgICAgIERlY2ltYWwyLmlzRGVjaW1hbCA9IGlzRGVjaW1hbEluc3RhbmNlO1xuICAgICAgRGVjaW1hbDIuYWJzID0gYWJzO1xuICAgICAgRGVjaW1hbDIuYWNvcyA9IGFjb3M7XG4gICAgICBEZWNpbWFsMi5hY29zaCA9IGFjb3NoO1xuICAgICAgRGVjaW1hbDIuYWRkID0gYWRkO1xuICAgICAgRGVjaW1hbDIuYXNpbiA9IGFzaW47XG4gICAgICBEZWNpbWFsMi5hc2luaCA9IGFzaW5oO1xuICAgICAgRGVjaW1hbDIuYXRhbiA9IGF0YW47XG4gICAgICBEZWNpbWFsMi5hdGFuaCA9IGF0YW5oO1xuICAgICAgRGVjaW1hbDIuYXRhbjIgPSBhdGFuMjtcbiAgICAgIERlY2ltYWwyLmNicnQgPSBjYnJ0O1xuICAgICAgRGVjaW1hbDIuY2VpbCA9IGNlaWw7XG4gICAgICBEZWNpbWFsMi5jb3MgPSBjb3M7XG4gICAgICBEZWNpbWFsMi5jb3NoID0gY29zaDtcbiAgICAgIERlY2ltYWwyLmRpdiA9IGRpdjtcbiAgICAgIERlY2ltYWwyLmV4cCA9IGV4cDtcbiAgICAgIERlY2ltYWwyLmZsb29yID0gZmxvb3I7XG4gICAgICBEZWNpbWFsMi5oeXBvdCA9IGh5cG90O1xuICAgICAgRGVjaW1hbDIubG4gPSBsbjtcbiAgICAgIERlY2ltYWwyLmxvZyA9IGxvZztcbiAgICAgIERlY2ltYWwyLmxvZzEwID0gbG9nMTA7XG4gICAgICBEZWNpbWFsMi5sb2cyID0gbG9nMjtcbiAgICAgIERlY2ltYWwyLm1heCA9IG1heDtcbiAgICAgIERlY2ltYWwyLm1pbiA9IG1pbjtcbiAgICAgIERlY2ltYWwyLm1vZCA9IG1vZDtcbiAgICAgIERlY2ltYWwyLm11bCA9IG11bDtcbiAgICAgIERlY2ltYWwyLnBvdyA9IHBvdztcbiAgICAgIERlY2ltYWwyLnJhbmRvbSA9IHJhbmRvbTtcbiAgICAgIERlY2ltYWwyLnJvdW5kID0gcm91bmQ7XG4gICAgICBEZWNpbWFsMi5zaWduID0gc2lnbjtcbiAgICAgIERlY2ltYWwyLnNpbiA9IHNpbjtcbiAgICAgIERlY2ltYWwyLnNpbmggPSBzaW5oO1xuICAgICAgRGVjaW1hbDIuc3FydCA9IHNxcnQ7XG4gICAgICBEZWNpbWFsMi5zdWIgPSBzdWI7XG4gICAgICBEZWNpbWFsMi50YW4gPSB0YW47XG4gICAgICBEZWNpbWFsMi50YW5oID0gdGFuaDtcbiAgICAgIERlY2ltYWwyLnRydW5jID0gdHJ1bmM7XG4gICAgICBpZiAob2JqID09PSB2b2lkIDApXG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICBpZiAob2JqLmRlZmF1bHRzICE9PSB0cnVlKSB7XG4gICAgICAgICAgcHMgPSBbXCJwcmVjaXNpb25cIiwgXCJyb3VuZGluZ1wiLCBcInRvRXhwTmVnXCIsIFwidG9FeHBQb3NcIiwgXCJtYXhFXCIsIFwibWluRVwiLCBcIm1vZHVsb1wiLCBcImNyeXB0b1wiXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyApXG4gICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwID0gcHNbaSsrXSkpXG4gICAgICAgICAgICAgIG9ialtwXSA9IHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIERlY2ltYWwyLmNvbmZpZyhvYmopO1xuICAgICAgcmV0dXJuIERlY2ltYWwyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXYoeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXhwKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxvb3IoeCkge1xuICAgICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh5cG90KCkge1xuICAgICAgdmFyIGksIG4sIHQgPSBuZXcgdGhpcygwKTtcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICAgIGlmICghbi5kKSB7XG4gICAgICAgICAgaWYgKG4ucykge1xuICAgICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKDEgLyAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdCA9IG47XG4gICAgICAgIH0gZWxzZSBpZiAodC5kKSB7XG4gICAgICAgICAgdCA9IHQucGx1cyhuLnRpbWVzKG4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHQuc3FydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxJbnN0YW5jZShvYmopIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoubmFtZSA9PT0gXCJbb2JqZWN0IERlY2ltYWxdXCIgfHwgZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxuKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2coeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZyh5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgXCJsdFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgXCJndFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kKHgsIHkpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5tb2QoeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11bCh4LCB5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3coeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZG9tKHNkKSB7XG4gICAgICB2YXIgZCwgZSwgaywgbiwgaSA9IDAsIHIgPSBuZXcgdGhpcygxKSwgcmQgPSBbXTtcbiAgICAgIGlmIChzZCA9PT0gdm9pZCAwKVxuICAgICAgICBzZCA9IHRoaXMucHJlY2lzaW9uO1xuICAgICAgZWxzZVxuICAgICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICAgIGsgPSBNYXRoLmNlaWwoc2QgLyBMT0dfQkFTRSk7XG4gICAgICBpZiAoIXRoaXMuY3J5cHRvKSB7XG4gICAgICAgIGZvciAoOyBpIDwgazsgKVxuICAgICAgICAgIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcbiAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBkID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaykpO1xuICAgICAgICBmb3IgKDsgaSA8IGs7ICkge1xuICAgICAgICAgIG4gPSBkW2ldO1xuICAgICAgICAgIGlmIChuID49IDQyOWU3KSB7XG4gICAgICAgICAgICBkW2ldID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZFtpKytdID0gbiAlIDFlNztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICAgIGQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA0KTtcbiAgICAgICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMTI3KSA8PCAyNCk7XG4gICAgICAgICAgaWYgKG4gPj0gMjE0ZTcpIHtcbiAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZC5wdXNoKG4gJSAxZTcpO1xuICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpID0gayAvIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XG4gICAgICB9XG4gICAgICBrID0gcmRbLS1pXTtcbiAgICAgIHNkICU9IExPR19CQVNFO1xuICAgICAgaWYgKGsgJiYgc2QpIHtcbiAgICAgICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xuICAgICAgICByZFtpXSA9IChrIC8gbiB8IDApICogbjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyByZFtpXSA9PT0gMDsgaS0tKVxuICAgICAgICByZC5wb3AoKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBlID0gMDtcbiAgICAgICAgcmQgPSBbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlID0gLTE7XG4gICAgICAgIGZvciAoOyByZFswXSA9PT0gMDsgZSAtPSBMT0dfQkFTRSlcbiAgICAgICAgICByZC5zaGlmdCgpO1xuICAgICAgICBmb3IgKGsgPSAxLCBuID0gcmRbMF07IG4gPj0gMTA7IG4gLz0gMTApXG4gICAgICAgICAgaysrO1xuICAgICAgICBpZiAoayA8IExPR19CQVNFKVxuICAgICAgICAgIGUgLT0gTE9HX0JBU0UgLSBrO1xuICAgICAgfVxuICAgICAgci5lID0gZTtcbiAgICAgIHIuZCA9IHJkO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdW5kKHgpIHtcbiAgICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgIHggPSBuZXcgdGhpcyh4KTtcbiAgICAgIHJldHVybiB4LmQgPyB4LmRbMF0gPyB4LnMgOiAwICogeC5zIDogeC5zIHx8IE5hTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2luKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkuc2luaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1Yih4LCB5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoeCkuc3ViKHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YW4oeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyh4KS50YW5oKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xuICAgIH1cbiAgICBEZWNpbWFsID0gY2xvbmUoREVGQVVMVFMpO1xuICAgIERlY2ltYWxbXCJkZWZhdWx0XCJdID0gRGVjaW1hbC5EZWNpbWFsID0gRGVjaW1hbDtcbiAgICBMTjEwID0gbmV3IERlY2ltYWwoTE4xMCk7XG4gICAgUEkgPSBuZXcgRGVjaW1hbChQSSk7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWw7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUyICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlMi5leHBvcnRzKSB7XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIFBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSA9IFAudG9TdHJpbmc7XG4gICAgICAgIFBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiRGVjaW1hbFwiO1xuICAgICAgfVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0gRGVjaW1hbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFnbG9iYWxTY29wZSkge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9IFwidW5kZWZpbmVkXCIgJiYgc2VsZiAmJiBzZWxmLnNlbGYgPT0gc2VsZiA/IHNlbGYgOiB3aW5kb3c7XG4gICAgICB9XG4gICAgICBub0NvbmZsaWN0ID0gZ2xvYmFsU2NvcGUuRGVjaW1hbDtcbiAgICAgIERlY2ltYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBnbG9iYWxTY29wZS5EZWNpbWFsID0gbm9Db25mbGljdDtcbiAgICAgICAgcmV0dXJuIERlY2ltYWw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsU2NvcGUuRGVjaW1hbCA9IERlY2ltYWw7XG4gICAgfVxuICB9KShleHBvcnRzMik7XG59KTtcblxuLy8gc3JjL3J1bnRpbWUvaW5kZXgtYnJvd3Nlci50c1xuX19leHBvcnQoZXhwb3J0cywge1xuICBEZWNpbWFsOiAoKSA9PiBkZWNpbWFsLmRlZmF1bHRcbn0pO1xudmFyIGRlY2ltYWwgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZGVjaW1hbCgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/runtime/index-browser.js\n");

/***/ }),

/***/ "./src/components/diff.js":
/*!********************************!*\
  !*** ./src/components/diff.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/esm/index.js\");\n/* harmony import */ var _components_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/layout */ \"./src/components/layout.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prisma/client */ \"./node_modules/@prisma/client/index-browser.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_3__);\nvar _this = undefined,\n    _jsxFileName = \"/home/veeresh/opensource/flocks-ui/src/components/diff.js\";\n\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\nvar Cell = function Cell(_ref) {\n  var children = _ref.children,\n      responsive = _ref.responsive,\n      header = _ref.header,\n      showMD = _ref.showMD;\n  var CellType = _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Td\"];\n\n  if (header) {\n    CellType = _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Th\"];\n  }\n\n  var displayType = ['none', 'none', 'None', 'table-cell', 'table-cell'];\n\n  if (showMD) {\n    displayType = ['none', 'none', 'table-cell', 'table-cell', 'table-cell'];\n  }\n\n  if (responsive) {\n    return __jsx(CellType, {\n      display: displayType,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 16\n      }\n    }, children);\n  }\n\n  return __jsx(CellType, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 12\n    }\n  }, children);\n};\n\n_c = Cell;\n\nvar Row = function Row(mf) {\n  var badgeColors = {\n    entry: 'green',\n    exit: 'red',\n    reduced: 'red',\n    increased: 'green',\n    held: 'gray'\n  };\n  return __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tr\"], {\n    key: mf.stock_name,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53,\n      columnNumber: 9\n    }\n  }, __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 13\n    }\n  }, \" \", mf.stock_name), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 55,\n      columnNumber: 13\n    }\n  }, mf.industry), __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 13\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Badge\"], {\n    variant: \"outline\",\n    colorScheme: badgeColors[mf.state],\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 17\n    }\n  }, mf.state)), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 13\n    }\n  }, mf.current_quantity), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 13\n    }\n  }, mf.previous_quantity), __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 13\n    }\n  }, mf.change_quantity), __jsx(Cell, {\n    responsive: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 13\n    }\n  }, Number(mf.change_market_value).toFixed(2)), __jsx(Cell, {\n    responsive: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 67,\n      columnNumber: 13\n    }\n  }, Number(mf.change_percentage_aum).toFixed(2)));\n};\n\n_c2 = Row;\n\nvar DiffPage = function DiffPage(_ref2) {\n  var caption = _ref2.caption,\n      mutual_funds = _ref2.mutual_funds;\n  return __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Stack\"], {\n    spacing: 2,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 9\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    fontSize: \"lg\",\n    ml: 6,\n    color: \"gray.600\",\n    as: \"b\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 13\n    }\n  }, \"Parag Parikh Long Term Equity Fund's portfolio changes in November, 2020.\"), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Divider\"], {\n    orientation: \"horizontal\",\n    colorScheme: \"teal\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 13\n    }\n  }), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Table\"], {\n    variant: \"simple\",\n    colorScheme: \"teal\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 13\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"TableCaption\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 17\n    }\n  }, caption), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Thead\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 17\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tr\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 21\n    }\n  }, __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 88,\n      columnNumber: 25\n    }\n  }, 'Stock name'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 25\n    }\n  }, 'Industry'), __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 25\n    }\n  }, 'State'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 25\n    }\n  }, 'Current Quantity'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 25\n    }\n  }, 'Previous Quantity'), __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 25\n    }\n  }, 'Change in Quantity'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 25\n    }\n  }, 'Change in Value(in Lacs)'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 25\n    }\n  }, 'Change in AUM %'))), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tbody\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 17\n    }\n  }, mutual_funds.entry.map(Row), mutual_funds.increased.map(Row), mutual_funds.held.map(Row), mutual_funds.reduced.map(Row), mutual_funds.exit.map(Row))));\n};\n\n_c3 = DiffPage;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"Cell\");\n$RefreshReg$(_c2, \"Row\");\n$RefreshReg$(_c3, \"DiffPage\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZGlmZi5qcz8yM2M2Il0sIm5hbWVzIjpbIkNlbGwiLCJjaGlsZHJlbiIsInJlc3BvbnNpdmUiLCJoZWFkZXIiLCJzaG93TUQiLCJDZWxsVHlwZSIsIlRkIiwiVGgiLCJkaXNwbGF5VHlwZSIsIlJvdyIsIm1mIiwiYmFkZ2VDb2xvcnMiLCJlbnRyeSIsImV4aXQiLCJyZWR1Y2VkIiwiaW5jcmVhc2VkIiwiaGVsZCIsInN0b2NrX25hbWUiLCJpbmR1c3RyeSIsInN0YXRlIiwiY3VycmVudF9xdWFudGl0eSIsInByZXZpb3VzX3F1YW50aXR5IiwiY2hhbmdlX3F1YW50aXR5IiwiTnVtYmVyIiwiY2hhbmdlX21hcmtldF92YWx1ZSIsInRvRml4ZWQiLCJjaGFuZ2VfcGVyY2VudGFnZV9hdW0iLCJEaWZmUGFnZSIsImNhcHRpb24iLCJtdXR1YWxfZnVuZHMiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBY0E7QUFFQTs7QUFFQSxJQUFNQSxJQUFJLEdBQUcsU0FBUEEsSUFBTyxPQUE4QztBQUFBLE1BQTNDQyxRQUEyQyxRQUEzQ0EsUUFBMkM7QUFBQSxNQUFqQ0MsVUFBaUMsUUFBakNBLFVBQWlDO0FBQUEsTUFBckJDLE1BQXFCLFFBQXJCQSxNQUFxQjtBQUFBLE1BQWJDLE1BQWEsUUFBYkEsTUFBYTtBQUN2RCxNQUFJQyxRQUFRLEdBQUdDLG1EQUFmOztBQUNBLE1BQUlILE1BQUosRUFBWTtBQUNSRSxZQUFRLEdBQUdFLG1EQUFYO0FBQ0g7O0FBRUQsTUFBSUMsV0FBVyxHQUFHLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUIsWUFBekIsRUFBdUMsWUFBdkMsQ0FBbEI7O0FBQ0EsTUFBSUosTUFBSixFQUFZO0FBQ1JJLGVBQVcsR0FBRyxDQUNWLE1BRFUsRUFFVixNQUZVLEVBR1YsWUFIVSxFQUlWLFlBSlUsRUFLVixZQUxVLENBQWQ7QUFPSDs7QUFFRCxNQUFJ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Q29udGVudCI6WyJpbXBvcnQge1xuICAgIFRhYmxlLFxuICAgIFRoZWFkLFxuICAgIFRib2R5LFxuICAgIFRleHQsXG4gICAgQmFkZ2UsXG4gICAgVHIsXG4gICAgVGgsXG4gICAgVGQsXG4gICAgVGFibGVDYXB0aW9uLFxuICAgIERpdmlkZXIsXG4gICAgU3RhY2tcbn0gZnJvbSAnQGNoYWtyYS11aS9yZWFjdCc7XG5cbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vY29tcG9uZW50cy9sYXlvdXQnO1xuXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5cbmNvbnN0IENlbGwgPSAoeyBjaGlsZHJlbiwgcmVzcG9uc2l2ZSwgaGVhZGVyLCBzaG93TUQgfSkgPT4ge1xuICAgIGxldCBDZWxsVHlwZSA9IFRkO1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgQ2VsbFR5cGUgPSBUaDtcbiAgICB9XG5cbiAgICBsZXQgZGlzcGxheVR5cGUgPSBbJ25vbmUnLCAnbm9uZScsICdOb25lJywgJ3RhYmxlLWNlbGwnLCAndGFibGUtY2VsbCddO1xuICAgIGlmIChzaG93TUQpIHtcbiAgICAgICAgZGlzcGxheVR5cGUgPSBbXG4gICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAndGFibGUtY2VsbCcsXG4gICAgICAgICAgICAndGFibGUtY2VsbCcsXG4gICAgICAgICAgICAndGFibGUtY2VsbCdcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2l2ZSkge1xuICAgICAgICByZXR1cm4gPENlbGxUeXBlIGRpc3BsYXk9e2Rpc3BsYXlUeXBlfT57Y2hpbGRyZW59PC9DZWxsVHlwZT47XG4gICAgfVxuXG4gICAgcmV0dXJuIDxDZWxsVHlwZT57Y2hpbGRyZW59PC9DZWxsVHlwZT47XG59O1xuXG5jb25zdCBSb3cgPSAobWYpID0+IHtcbiAgICBjb25zdCBiYWRnZUNvbG9ycyA9IHtcbiAgICAgICAgZW50cnk6ICdncmVlbicsXG4gICAgICAgIGV4aXQ6ICdyZWQnLFxuICAgICAgICByZWR1Y2VkOiAncmVkJyxcbiAgICAgICAgaW5jcmVhc2VkOiAnZ3JlZW4nLFxuICAgICAgICBoZWxkOiAnZ3JheSdcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFRyIGtleT17bWYuc3RvY2tfbmFtZX0+XG4gICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXtmYWxzZX0+IHttZi5zdG9ja19uYW1lfTwvQ2VsbD5cbiAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e3RydWV9PnttZi5pbmR1c3RyeX08L0NlbGw+XG4gICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXtmYWxzZX0+XG4gICAgICAgICAgICAgICAgPEJhZGdlIHZhcmlhbnQ9XCJvdXRsaW5lXCIgY29sb3JTY2hlbWU9e2JhZGdlQ29sb3JzW21mLnN0YXRlXX0+XG4gICAgICAgICAgICAgICAgICAgIHttZi5zdGF0ZX1cbiAgICAgICAgICAgICAgICA8L0JhZGdlPlxuICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0+e21mLmN1cnJlbnRfcXVhbnRpdHl9PC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0+e21mLnByZXZpb3VzX3F1YW50aXR5fTwvQ2VsbD5cbiAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfT57bWYuY2hhbmdlX3F1YW50aXR5fTwvQ2VsbD5cbiAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e3RydWV9IHNob3dNRD17dHJ1ZX0+XG4gICAgICAgICAgICAgICAge051bWJlcihtZi5jaGFuZ2VfbWFya2V0X3ZhbHVlKS50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0gc2hvd01EPXt0cnVlfT5cbiAgICAgICAgICAgICAgICB7TnVtYmVyKG1mLmNoYW5nZV9wZXJjZW50YWdlX2F1bSkudG9GaXhlZCgyKX1cbiAgICAgICAgICAgIDwvQ2VsbD5cbiAgICAgICAgPC9Ucj5cbiAgICApO1xufTtcblxuY29uc3QgRGlmZlBhZ2UgPSAoeyBjYXB0aW9uLCBtdXR1YWxfZnVuZHMgfSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTdGFjayBzcGFjaW5nPXsyfT5cbiAgICAgICAgICAgIDxUZXh0IGZvbnRTaXplPVwibGdcIiBtbD17Nn0gY29sb3I9XCJncmF5LjYwMFwiIGFzPVwiYlwiPlxuICAgICAgICAgICAgICAgIFBhcmFnIFBhcmlraCBMb25nIFRlcm0gRXF1aXR5IEZ1bmQncyBwb3J0Zm9saW8gY2hhbmdlcyBpblxuICAgICAgICAgICAgICAgIE5vdmVtYmVyLCAyMDIwLlxuICAgICAgICAgICAgPC9UZXh0PlxuXG4gICAgICAgICAgICA8RGl2aWRlciBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIiBjb2xvclNjaGVtZT1cInRlYWxcIiAvPlxuXG4gICAgICAgICAgICA8VGFibGUgdmFyaWFudD1cInNpbXBsZVwiIGNvbG9yU2NoZW1lPVwidGVhbFwiPlxuICAgICAgICAgICAgICAgIDxUYWJsZUNhcHRpb24+e2NhcHRpb259PC9UYWJsZUNhcHRpb24+XG4gICAgICAgICAgICAgICAgPFRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8VHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXtmYWxzZX0gaGVhZGVyPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1N0b2NrIG5hbWUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9DZWxsPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnSW5kdXN0cnknfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9DZWxsPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXtmYWxzZX0gaGVhZGVyPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1N0YXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0gaGVhZGVyPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J0N1cnJlbnQgUXVhbnRpdHknfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0gaGVhZGVyPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1ByZXZpb3VzIFF1YW50aXR5J31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnQ2hhbmdlIGluIFF1YW50aXR5J31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e3RydWV9IGhlYWRlcj17dHJ1ZX0gc2hvd01EPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J0NoYW5nZSBpbiBWYWx1ZShpbiBMYWNzKSd9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfSBoZWFkZXI9e3RydWV9IHNob3dNRD17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeydDaGFuZ2UgaW4gQVVNICUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICAgICAgICAgICAgICA8L1RyPlxuICAgICAgICAgICAgICAgIDwvVGhlYWQ+XG5cbiAgICAgICAgICAgICAgICA8VGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIHttdXR1YWxfZnVuZHMuZW50cnkubWFwKFJvdyl9XG4gICAgICAgICAgICAgICAgICAgIHttdXR1YWxfZnVuZHMuaW5jcmVhc2VkLm1hcChSb3cpfVxuICAgICAgICAgICAgICAgICAgICB7bXV0dWFsX2Z1bmRzLmhlbGQubWFwKFJvdyl9XG4gICAgICAgICAgICAgICAgICAgIHttdXR1YWxfZnVuZHMucmVkdWNlZC5tYXAoUm93KX1cbiAgICAgICAgICAgICAgICAgICAge211dHVhbF9mdW5kcy5leGl0Lm1hcChSb3cpfVxuICAgICAgICAgICAgICAgIDwvVGJvZHk+XG4gICAgICAgICAgICA8L1RhYmxlPlxuICAgICAgICA8L1N0YWNrPlxuICAgICk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/diff.js\n");

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/*! exports provided: __N_SSG, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__N_SSG\", function() { return __N_SSG; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/esm/index.js\");\n/* harmony import */ var _components_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/layout */ \"./src/components/layout.js\");\n/* harmony import */ var _components_diff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/diff */ \"./src/components/diff.js\");\nvar _this = undefined,\n    _jsxFileName = \"/home/veeresh/opensource/flocks-ui/src/pages/index.js\";\n\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\nvar Cell = function Cell(_ref) {\n  var children = _ref.children,\n      responsive = _ref.responsive,\n      header = _ref.header,\n      showMD = _ref.showMD;\n  var CellType = _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Td\"];\n\n  if (header) {\n    CellType = _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Th\"];\n  }\n\n  var displayType = ['none', 'none', 'None', 'table-cell', 'table-cell'];\n\n  if (showMD) {\n    displayType = ['none', 'none', 'table-cell', 'table-cell', 'table-cell'];\n  }\n\n  if (responsive) {\n    return __jsx(CellType, {\n      display: displayType,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 16\n      }\n    }, children);\n  }\n\n  return __jsx(CellType, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 12\n    }\n  }, children);\n};\n\n_c = Cell;\n\nvar Row = function Row(mf) {\n  var badgeColors = {\n    entry: 'green',\n    exit: 'red',\n    reduced: 'red',\n    increased: 'green',\n    held: 'gray'\n  };\n  return __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tr\"], {\n    key: mf.stock_name,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 9\n    }\n  }, __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 55,\n      columnNumber: 13\n    }\n  }, \" \", mf.stock_name), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 13\n    }\n  }, mf.industry), __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 13\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Badge\"], {\n    variant: \"outline\",\n    colorScheme: badgeColors[mf.state],\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 17\n    }\n  }, mf.state)), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 13\n    }\n  }, mf.current_quantity), __jsx(Cell, {\n    responsive: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 13\n    }\n  }, mf.previous_quantity), __jsx(Cell, {\n    responsive: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 13\n    }\n  }, mf.change_quantity), __jsx(Cell, {\n    responsive: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 13\n    }\n  }, Number(mf.change_market_value).toFixed(2)), __jsx(Cell, {\n    responsive: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 68,\n      columnNumber: 13\n    }\n  }, Number(mf.change_percentage_aum).toFixed(2)));\n};\n\n_c2 = Row;\n\nvar IndexPage = function IndexPage(_ref2) {\n  var caption = _ref2.caption,\n      mutual_funds = _ref2.mutual_funds;\n  return __jsx(_components_layout__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 9\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Stack\"], {\n    spacing: 2,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 78,\n      columnNumber: 13\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    fontSize: \"lg\",\n    ml: 6,\n    color: \"gray.600\",\n    as: \"b\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 17\n    }\n  }, \"Parag Parikh Long Term Equity Fund's portfolio changes in November, 2020.\"), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Divider\"], {\n    orientation: \"horizontal\",\n    colorScheme: \"teal\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 17\n    }\n  }), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Table\"], {\n    variant: \"simple\",\n    colorScheme: \"teal\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 17\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"TableCaption\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 21\n    }\n  }, caption), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Thead\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 88,\n      columnNumber: 21\n    }\n  }, __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tr\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 25\n    }\n  }, __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90,\n      columnNumber: 29\n    }\n  }, 'Stock name'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 29\n    }\n  }, 'Industry'), __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 29\n    }\n  }, 'State'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 29\n    }\n  }, 'Current Quantity'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 29\n    }\n  }, 'Previous Quantity'), __jsx(Cell, {\n    responsive: false,\n    header: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 29\n    }\n  }, 'Change in Quantity'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 29\n    }\n  }, 'Change in Value(in Lacs)'), __jsx(Cell, {\n    responsive: true,\n    header: true,\n    showMD: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 29\n    }\n  }, 'Change in AUM %'))), __jsx(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__[\"Tbody\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 21\n    }\n  }, mutual_funds.entry.map(Row), mutual_funds.increased.map(Row), mutual_funds.held.map(Row), mutual_funds.reduced.map(Row), mutual_funds.exit.map(Row)))));\n};\n\n_c3 = IndexPage;\nvar __N_SSG = true;\n/* harmony default export */ __webpack_exports__[\"default\"] = (IndexPage);\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"Cell\");\n$RefreshReg$(_c2, \"Row\");\n$RefreshReg$(_c3, \"IndexPage\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2luZGV4LmpzPzQ1NzAiXSwibmFtZXMiOlsiQ2VsbCIsImNoaWxkcmVuIiwicmVzcG9uc2l2ZSIsImhlYWRlciIsInNob3dNRCIsIkNlbGxUeXBlIiwiVGQiLCJUaCIsImRpc3BsYXlUeXBlIiwiUm93IiwibWYiLCJiYWRnZUNvbG9ycyIsImVudHJ5IiwiZXhpdCIsInJlZHVjZWQiLCJpbmNyZWFzZWQiLCJoZWxkIiwic3RvY2tfbmFtZSIsImluZHVzdHJ5Iiwic3RhdGUiLCJjdXJyZW50X3F1YW50aXR5IiwicHJldmlvdXNfcXVhbnRpdHkiLCJjaGFuZ2VfcXVhbnRpdHkiLCJOdW1iZXIiLCJjaGFuZ2VfbWFya2V0X3ZhbHVlIiwidG9GaXhlZCIsImNoYW5nZV9wZXJjZW50YWdlX2F1bSIsIkluZGV4UGFnZSIsImNhcHRpb24iLCJtdXR1YWxfZnVuZHMiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBY0E7QUFDQTs7QUFJQSxJQUFNQSxJQUFJLEdBQUcsU0FBUEEsSUFBTyxPQUE4QztBQUFBLE1BQTNDQyxRQUEyQyxRQUEzQ0EsUUFBMkM7QUFBQSxNQUFqQ0MsVUFBaUMsUUFBakNBLFVBQWlDO0FBQUEsTUFBckJDLE1BQXFCLFFBQXJCQSxNQUFxQjtBQUFBLE1BQWJDLE1BQWEsUUFBYkEsTUFBYTtBQUN2RCxNQUFJQyxRQUFRLEdBQUdDLG1EQUFmOztBQUNBLE1BQUlILE1BQUosRUFBWTtBQUNSRSxZQUFRLEdBQUdFLG1EQUFYO0FBQ0g7O0FBRUQsTUFBSUMsV0FBVyxHQUFHLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUIsWUFBekIsRUFBdUMsWUFBdkMsQ0FBbEI7O0FBQ0EsTUFBSUosTUFBSixFQUFZO0FBQ1JJLGVBQVcsR0FBRyxDQUNWLE1BRFUsRUFFVixNQUZVLEVBR1YsWUFIVSxFQUlWLFlBSlUsRUFLVixZQUxVLENBQWQ7QUFPSDs7QUFFRCxNQUFJTixV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QU1rQixTOztBQTZHU0Esd0VBQWYiLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIFRhYmxlLFxuICAgIFRoZWFkLFxuICAgIFRib2R5LFxuICAgIFRleHQsXG4gICAgQmFkZ2UsXG4gICAgVHIsXG4gICAgVGgsXG4gICAgVGQsXG4gICAgVGFibGVDYXB0aW9uLFxuICAgIERpdmlkZXIsXG4gICAgU3RhY2tcbn0gZnJvbSAnQGNoYWtyYS11aS9yZWFjdCc7XG5cbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vY29tcG9uZW50cy9sYXlvdXQnO1xuaW1wb3J0IERpZmZQYWdlIGZyb20gJy4uL2NvbXBvbmVudHMvZGlmZic7XG5cbmltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gJ0BwcmlzbWEvY2xpZW50JztcblxuY29uc3QgQ2VsbCA9ICh7IGNoaWxkcmVuLCByZXNwb25zaXZlLCBoZWFkZXIsIHNob3dNRCB9KSA9PiB7XG4gICAgbGV0IENlbGxUeXBlID0gVGQ7XG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgICBDZWxsVHlwZSA9IFRoO1xuICAgIH1cblxuICAgIGxldCBkaXNwbGF5VHlwZSA9IFsnbm9uZScsICdub25lJywgJ05vbmUnLCAndGFibGUtY2VsbCcsICd0YWJsZS1jZWxsJ107XG4gICAgaWYgKHNob3dNRCkge1xuICAgICAgICBkaXNwbGF5VHlwZSA9IFtcbiAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICAgICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICAgICd0YWJsZS1jZWxsJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgIHJldHVybiA8Q2VsbFR5cGUgZGlzcGxheT17ZGlzcGxheVR5cGV9PntjaGlsZHJlbn08L0NlbGxUeXBlPjtcbiAgICB9XG5cbiAgICByZXR1cm4gPENlbGxUeXBlPntjaGlsZHJlbn08L0NlbGxUeXBlPjtcbn07XG5cbmNvbnN0IFJvdyA9IChtZikgPT4ge1xuICAgIGNvbnN0IGJhZGdlQ29sb3JzID0ge1xuICAgICAgICBlbnRyeTogJ2dyZWVuJyxcbiAgICAgICAgZXhpdDogJ3JlZCcsXG4gICAgICAgIHJlZHVjZWQ6ICdyZWQnLFxuICAgICAgICBpbmNyZWFzZWQ6ICdncmVlbicsXG4gICAgICAgIGhlbGQ6ICdncmF5J1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VHIga2V5PXttZi5zdG9ja19uYW1lfT5cbiAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfT4ge21mLnN0b2NrX25hbWV9PC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0+e21mLmluZHVzdHJ5fTwvQ2VsbD5cbiAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfT5cbiAgICAgICAgICAgICAgICA8QmFkZ2UgdmFyaWFudD1cIm91dGxpbmVcIiBjb2xvclNjaGVtZT17YmFkZ2VDb2xvcnNbbWYuc3RhdGVdfT5cbiAgICAgICAgICAgICAgICAgICAge21mLnN0YXRlfVxuICAgICAgICAgICAgICAgIDwvQmFkZ2U+XG4gICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfT57bWYuY3VycmVudF9xdWFudGl0eX08L0NlbGw+XG4gICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfT57bWYucHJldmlvdXNfcXVhbnRpdHl9PC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17ZmFsc2V9PnttZi5jaGFuZ2VfcXVhbnRpdHl9PC9DZWxsPlxuICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0gc2hvd01EPXt0cnVlfT5cbiAgICAgICAgICAgICAgICB7TnVtYmVyKG1mLmNoYW5nZV9tYXJrZXRfdmFsdWUpLnRvRml4ZWQoMil9XG4gICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfSBzaG93TUQ9e3RydWV9PlxuICAgICAgICAgICAgICAgIHtOdW1iZXIobWYuY2hhbmdlX3BlcmNlbnRhZ2VfYXVtKS50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICA8L1RyPlxuICAgICk7XG59O1xuXG5jb25zdCBJbmRleFBhZ2UgPSAoeyBjYXB0aW9uLCBtdXR1YWxfZnVuZHMgfSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxMYXlvdXQ+XG4gICAgICAgICAgICA8U3RhY2sgc3BhY2luZz17Mn0+XG4gICAgICAgICAgICAgICAgPFRleHQgZm9udFNpemU9XCJsZ1wiIG1sPXs2fSBjb2xvcj1cImdyYXkuNjAwXCIgYXM9XCJiXCI+XG4gICAgICAgICAgICAgICAgICAgIFBhcmFnIFBhcmlraCBMb25nIFRlcm0gRXF1aXR5IEZ1bmQncyBwb3J0Zm9saW8gY2hhbmdlcyBpblxuICAgICAgICAgICAgICAgICAgICBOb3ZlbWJlciwgMjAyMC5cbiAgICAgICAgICAgICAgICA8L1RleHQ+XG5cbiAgICAgICAgICAgICAgICA8RGl2aWRlciBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIiBjb2xvclNjaGVtZT1cInRlYWxcIiAvPlxuXG4gICAgICAgICAgICAgICAgPFRhYmxlIHZhcmlhbnQ9XCJzaW1wbGVcIiBjb2xvclNjaGVtZT1cInRlYWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlQ2FwdGlvbj57Y2FwdGlvbn08L1RhYmxlQ2FwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPFRoZWFkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1N0b2NrIG5hbWUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e3RydWV9IGhlYWRlcj17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnSW5kdXN0cnknfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e2ZhbHNlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1N0YXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0NlbGw+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J0N1cnJlbnQgUXVhbnRpdHknfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2VsbCByZXNwb25zaXZlPXt0cnVlfSBoZWFkZXI9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1ByZXZpb3VzIFF1YW50aXR5J31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17ZmFsc2V9IGhlYWRlcj17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnQ2hhbmdlIGluIFF1YW50aXR5J31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENlbGwgcmVzcG9uc2l2ZT17dHJ1ZX0gaGVhZGVyPXt0cnVlfSBzaG93TUQ9e3RydWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J0NoYW5nZSBpbiBWYWx1ZShpbiBMYWNzKSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9DZWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDZWxsIHJlc3BvbnNpdmU9e3RydWV9IGhlYWRlcj17dHJ1ZX0gc2hvd01EPXt0cnVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeydDaGFuZ2UgaW4gQVVNICUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvVHI+XG4gICAgICAgICAgICAgICAgICAgIDwvVGhlYWQ+XG5cbiAgICAgICAgICAgICAgICAgICAgPFRib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAge211dHVhbF9mdW5kcy5lbnRyeS5tYXAoUm93KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHttdXR1YWxfZnVuZHMuaW5jcmVhc2VkLm1hcChSb3cpfVxuICAgICAgICAgICAgICAgICAgICAgICAge211dHVhbF9mdW5kcy5oZWxkLm1hcChSb3cpfVxuICAgICAgICAgICAgICAgICAgICAgICAge211dHVhbF9mdW5kcy5yZWR1Y2VkLm1hcChSb3cpfVxuICAgICAgICAgICAgICAgICAgICAgICAge211dHVhbF9mdW5kcy5leGl0Lm1hcChSb3cpfVxuICAgICAgICAgICAgICAgICAgICA8L1Rib2R5PlxuICAgICAgICAgICAgICAgIDwvVGFibGU+XG4gICAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L0xheW91dD5cbiAgICApO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0YXRpY1Byb3BzKGNvbnRleHQpIHtcbiAgICBjb25zdCBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCk7XG5cbiAgICBsZXQgbWZzID0gYXdhaXQgcHJpc21hLm1mX2RpZmYuZmluZE1hbnkoe1xuICAgICAgICBvcmRlckJ5OiB7XG4gICAgICAgICAgICBjaGFuZ2VfbWFya2V0X3ZhbHVlOiAnZGVzYydcbiAgICAgICAgfSxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGZ1bmRfaG91c2U6IHtcbiAgICAgICAgICAgICAgICBlcXVhbHM6ICdQUExUVkYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudF9tb250aDoge1xuICAgICAgICAgICAgICAgIGVxdWFsczogOVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW1mcykge1xuICAgICAgICBjb25zb2xlLmxvZygnRW1wdHkgbXV0dWFsIGZ1bmRzIGZvciBRTFRFVkYnKTtcbiAgICAgICAgbWZzID0gW107XG4gICAgfVxuXG4gICAgbGV0IG11dHVhbF9mdW5kcyA9IHtcbiAgICAgICAgZW50cnk6IFtdLFxuICAgICAgICBleGl0OiBbXSxcbiAgICAgICAgcmVkdWNlZDogW10sXG4gICAgICAgIGluY3JlYXNlZDogW10sXG4gICAgICAgIGhlbGQ6IFtdXG4gICAgfTtcblxuICAgIG1mcy5tYXAoKG1mKSA9PlxuICAgICAgICBtdXR1YWxfZnVuZHNbbWYuc3RhdGUudG9TdHJpbmcoKV0ucHVzaCh7XG4gICAgICAgICAgICBzdG9ja19uYW1lOiBtZi5zdG9ja19uYW1lLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBpbmR1c3RyeTogbWYuaW5kdXN0cnkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXRlOiBtZi5zdGF0ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgY3VycmVudF9xdWFudGl0eTogbWYuY3VycmVudF9xdWFudGl0eS50b1N0cmluZygpLFxuICAgICAgICAgICAgcHJldmlvdXNfcXVhbnRpdHk6IG1mLnByZXZpb3VzX3F1YW50aXR5LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjaGFuZ2VfcXVhbnRpdHk6IG1mLmNoYW5nZV9xdWFudGl0eS50b1N0cmluZygpLFxuICAgICAgICAgICAgY2hhbmdlX21hcmtldF92YWx1ZTogbWYuY2hhbmdlX21hcmtldF92YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgY2hhbmdlX3BlcmNlbnRhZ2VfYXVtOiBtZi5jaGFuZ2VfcGVyY2VudGFnZV9hdW0udG9TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ1BhcmFnIFBhcmlraCBMb25nIFRlcm0gRXF1aXR5IEZ1bmQnLFxuICAgICAgICAgICAgbXV0dWFsX2Z1bmRzOiBtdXR1YWxfZnVuZHNcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluZGV4UGFnZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.js\n");

/***/ })

})